<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>赵志凡'Blog</title><link href="http://blog.zzfanhero.info/" rel="alternate"></link><link href="http://blog.zzfanhero.info/feeds/coding.atom.xml" rel="self"></link><id>http://blog.zzfanhero.info/</id><updated>2016-03-26T00:00:00+08:00</updated><entry><title>AVL和红黑树</title><link href="http://blog.zzfanhero.info/articles/avlhe-hong-hei-shu.html" rel="alternate"></link><updated>2016-03-26T00:00:00+08:00</updated><author><name>zzfan</name></author><id>tag:blog.zzfanhero.info,2016-03-26:articles/avlhe-hong-hei-shu.html</id><summary type="html">&lt;p&gt;&lt;font size=4 color=Green&gt;摘要：刚看完二叉搜索树和堆，二叉搜索树的建立并没有平衡方面的考虑，AVL(平衡二叉树的算法很好的解决了这一点)，红黑树也是一个非常好的结构，这两个结构中插入的旋转操作有点麻烦，特别是红黑树。&lt;/font&gt;  &lt;/p&gt;</summary><category term="数据结构"></category><category term="面试"></category><category term="笔试"></category></entry><entry><title>线程池</title><link href="http://blog.zzfanhero.info/articles/xian-cheng-chi.html" rel="alternate"></link><updated>2016-03-19T00:00:00+08:00</updated><author><name>zzfan</name></author><id>tag:blog.zzfanhero.info,2016-03-19:articles/xian-cheng-chi.html</id><summary type="html"></summary><category term="code"></category></entry><entry><title>二叉树搜索树和堆</title><link href="http://blog.zzfanhero.info/articles/er-cha-shu-sou-suo-shu-he-dui.html" rel="alternate"></link><updated>2016-03-17T00:00:00+08:00</updated><author><name>zzfan</name></author><id>tag:blog.zzfanhero.info,2016-03-17:articles/er-cha-shu-sou-suo-shu-he-dui.html</id><summary type="html">&lt;p&gt;&lt;font size=4 color=Green&gt;摘要：面试的时候以及笔试的时候都有很多关于树的问题，这篇文章把树的基本知识总结下。&lt;/font&gt;&lt;/p&gt;
&lt;h3&gt;* 二叉搜索树&lt;/h3&gt;
&lt;p&gt;二叉查找树（BinarySearch Tree，也叫二叉搜索树，或称二叉排序树Binary Sort Tree）或者是一棵空树，或者是具有下列性质的二叉树：  &lt;/p&gt;
&lt;p&gt;（1）、若它的左子树不为空，则左子树上所有结点的值均小于它的根结点的值；  &lt;/p&gt;
&lt;p&gt;（2）、若它的右子树不为空，则右子树上所有结点的值均大于它的根结点的值；  &lt;/p&gt;
&lt;p&gt;（3）、它的左、右子树也分别为二叉查找树。  &lt;/p&gt;
&lt;p&gt;&lt;font color=Red size=4&gt;分析：除非小心行事，否则一颗n个元素的二叉查找树的高度可能位n。查找/插入/删除操作都是O（h），二叉查找树的平均高度位O（logn)。&lt;/font&gt;  &lt;/p&gt;
&lt;h3&gt;* 堆&lt;/h3&gt;
&lt;h4&gt;+ 定义&lt;/h4&gt;
&lt;p&gt;二叉堆是完全二叉树或者是近似完全二叉树。  &lt;/p&gt;
&lt;p&gt;二叉堆满足二个特性：  &lt;/p&gt;
&lt;p&gt;1．父结点的键值总是大于或等于（小于或等于）任何一个子节点的键值。  &lt;/p&gt;
&lt;p&gt;2．每个结点的左子树和右子树都是一个二叉堆（都是最大堆或最小堆）。  &lt;/p&gt;
&lt;p&gt;当父结点的键值总是大于或等于任何一个子节点的键值时为最大堆。当父结点的键值总是小于或等于任何一个子节点的键值时为最小堆。下图展示一个最小堆：&lt;br /&gt;
&lt;img alt="heap1" src="/images/heap/1.gif" /&gt;  &lt;/p&gt;
&lt;h4&gt;+ 堆的存储&lt;/h4&gt;
&lt;p&gt;一般都用数组来表示堆，i结点的父结点下标就为(i – 1) / 2。它的左右子结点下标分别为2 * i + 1和2 * i + 2。如第0个结点左右子结点下标分别为1和2。&lt;br /&gt;
&lt;img alt="heap2" src="/images/heap/2.gif" /&gt;  &lt;/p&gt;
&lt;h4&gt;+堆排序&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/*************************************************************************&lt;/span&gt;
&lt;span class="cm"&gt;    &amp;gt; File Name: test5.cpp&lt;/span&gt;
&lt;span class="cm"&gt;    &amp;gt; Author: zzfan&lt;/span&gt;
&lt;span class="cm"&gt;    &amp;gt; Mail: zzfan@mail.ustc.edu.cn &lt;/span&gt;
&lt;span class="cm"&gt;    &amp;gt; Created Time: Sat 26 Mar 2016 07:57:07 PM HKT&lt;/span&gt;
&lt;span class="cm"&gt; ************************************************************************/&lt;/span&gt;

&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;algorithm&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;max_heapify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[],&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;end&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="c1"&gt;//建立父节点指标和子节点指标&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;dad&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;son&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dad&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;son&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nf"&gt;end&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="c1"&gt;//若子节点指标在范围内才做比较&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;son&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="nf"&gt;end&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;son&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;son&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
            &lt;span class="n"&gt;son&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;dad&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;son&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;dad&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;son&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
            &lt;span class="n"&gt;dad&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;son&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
            &lt;span class="n"&gt;son&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dad&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;heap_sort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[],&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="c1"&gt;//初始化，i从最后一个父节点开始调整&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;max_heapify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="c1"&gt;//先将第一个元素和已拍好元素前一位做交换，再重新调整，知道排序完成&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
        &lt;span class="n"&gt;max_heapify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;heap_sort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39; &amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;font size=4 color=Red&gt;分析：堆的建立要O（n*logn)的时间，每次取堆的最大元素后重新调整也要O(logn)，因此真个时间消耗任然为O(nlogn).&lt;/font&gt;  &lt;/p&gt;</summary><category term="数据结构"></category><category term="面试"></category><category term="笔试"></category></entry><entry><title>进程和线程</title><link href="http://blog.zzfanhero.info/articles/jin-cheng-he-xian-cheng.html" rel="alternate"></link><updated>2016-03-16T00:00:00+08:00</updated><author><name>zzfan</name></author><id>tag:blog.zzfanhero.info,2016-03-16:articles/jin-cheng-he-xian-cheng.html</id><summary type="html">&lt;p&gt;&lt;font color=Green&gt;概述：操作系统看的不是很详细，突然看到&lt;code&gt;volatile&lt;/code&gt;这个关键字，然后就想总结下． &lt;/font&gt;&lt;/p&gt;
&lt;h3&gt;*volatile&lt;/h3&gt;
&lt;p&gt;使用volatile关键字声明的变量或对象通常具有与优化/多线程相关的特殊属性．通常volatile关键字用来阻止编译器认为的无法＂被代码本身＂改变的代码（变量／对象）进行优化．在C/C++中，volatile关键字可以用来提醒编译器它后面所定义的变量随时有可能改变，因此编译后的程序每次需要存储或读取这个变量的时候，都会直接从变量地址中读取数据．如果没有volatile关键字，则编译器可能优化读取和存储，可能暂时使用寄存器中的值，如果这个变量由别的程序更新了的话，讲出现不一致的现象．&lt;/p&gt;
&lt;h3&gt;*概念介绍&lt;/h3&gt;
&lt;p&gt;进程，是并发执行的程序再执行过程中分配和管理资源的基本单位，是一个动态概念，竞争计算机系统资源的基本单位．每一个基础南横都有一个自己的地址空间，即进程空间或需空间．进程空间的大小只与处理机的位数有关．进程至少有５种状态，他们是：初始，执行，阻塞，就绪，结束&lt;/p&gt;
&lt;p&gt;线程，再网络或多用户环境下，一个服务器通常需要接收大量且不确定数量用户的并发请求，为每一个请求都创建一个进程显然使行不通的．因此操作系统中线程的概念便被引进了．线程，是进程的一部分，一个没有线程的进程可以被看做是单线程的．线程有时又被称为轻权进程或轻量级进程，也是ＣＰＵ调度的一个基本单位．&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;进程的执行过程是线状的&lt;/em&gt;&lt;/strong&gt;,尽管中间会发生终端或暂停，但该进程所拥有的资源只为该线状执行过程服务．一旦发生进程上下文切换，这些资源都是要被保护起来的．这是宏观上的执行过程．而进程又可有单线程进程与多鲜橙进程两种．&lt;strong&gt;&lt;em&gt;线程的改变只代表了cpu执行过程的改变而没有发生进程所拥有的资源变化，进程拥有一个完整的虚拟地址空间，布衣赖域线程而独立存在；反之，线程是进程的一部分，没有自己的地址空间，域进程内的其他线程一起共享分配该进程的所有资源&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;线程的执行特性&lt;br /&gt;
　线程只有３个基本状态：就绪，执行，阻塞．&lt;br /&gt;
　线程存在５种基本操作来切换线程的状态：派生，阻塞，激活，调度，结束．  &lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进程通信&lt;br /&gt;
主从式：终端控制进程和终端进程&lt;br /&gt;
会话式：用户进程域磁盘管理进程之间的通信&lt;br /&gt;
管道: 
　A.管道是半双工的，数据只能向一个方向流动；双方通信需要建立起两个管道&lt;br /&gt;
　B.只能用于父子进程或者兄弟进程之间&lt;br /&gt;
　C.是在内存中单独构成一种文件系统，只存在于内存中.&lt;br /&gt;
共享内存&lt;br /&gt;
两个进程职位的内存快，两个进程均可以访问&lt;br /&gt;
锁机制&lt;br /&gt;
套接字&lt;br /&gt;
信号  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;线程间通信&lt;br /&gt;
锁机制：互斥锁／条件变量／读写锁&lt;br /&gt;
信号量&lt;br /&gt;
信号机制  &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary><category term="system"></category></entry><entry><title>堆栈以及大小端解析</title><link href="http://blog.zzfanhero.info/articles/dui-zhan-yi-ji-da-xiao-duan-jie-xi.html" rel="alternate"></link><updated>2016-03-08T00:00:00+08:00</updated><author><name>zzfan</name></author><id>tag:blog.zzfanhero.info,2016-03-08:articles/dui-zhan-yi-ji-da-xiao-duan-jie-xi.html</id><summary type="html">&lt;h3&gt;简介&lt;/h3&gt;
&lt;p&gt;在程序的设计中，都会设计堆栈的使用，其中堆使通过用户来调用的内存空间，需要用户主动分配和释放，如果只分配而不立即释放，则可能出现内存泄露的问题，其结果是难以估量的；
栈使系统自动调用的内存空间，系统也会根据实际情况自动去释放该空间．&lt;/p&gt;
&lt;p&gt;在平时的使用当中，我们需要注意堆栈的增长方向，一般来说，当堆栈指针（栈顶）由高地址向低地址增长时，我们称为向下增长；当堆栈指针（栈顶）由低地址向高地址增长时，我们称为向上增长．&lt;/p&gt;
&lt;p&gt;当然在程序设计中我们还需要注意的就是数据存储的方式：&lt;font color=OrangeRed&gt;大端存储／小端存储 &lt;/font&gt;．&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;大端存储--数据的高位字节保存再内存的低地址中，而数据的低位字节保存在内存的高地址中，这样的存储模式有点类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放;&lt;br /&gt;
  小端存储--数据的高位字节保存再内存的高地址中，而数据的低位字节保存在内存的低地址中，和我们的逻辑方式一致．  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;大小端测试方法&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;这是一个面试题  &lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int main()
{
    long long a=1;
    long long b=2;
    long long c=3;
    printf(&amp;quot;%d,%d,%d&amp;quot;,a,b,c);
    return 0;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;输出结果是什么？（32位环境，cpu为小端模式，所有参数用栈传递）&lt;br /&gt;
&lt;font color=Orange&gt;无论是在32/64环境中long long都是８个字节，参数从右到左进栈，栈中从栈底到栈顶依次为c/b/a，％d将打印栈中的４个字节，又因为是小端模式，所以打印结果为: 1 0 2&lt;/font&gt;   &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第二题  &lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;unsigned int a=0x1234;
unsigned char b=*(unsigned char*)&amp;amp;a;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在32位大端模式处理器上变量b=?&lt;br /&gt;
&lt;font color=Orange&gt;大端存储，从低地址到高地址存储的为0x34、0x12，b指针指向a的第一个字节即0x34，0x34转换为ascii为0，所以输出结果为0.&lt;/font&gt;&lt;/p&gt;
&lt;h3&gt;分析&lt;/h3&gt;
&lt;p&gt;&lt;font color=Orange&gt;小端模式下，因为高地址再上，所以栈往低地址处延伸．所以先把先来者往低地址处压栈，再把后来者往高地址处压栈. 大端模式，因为低地址在上，所以栈往高低脂外延伸．所以先把先来者往高地址处压栈，再把后来者往低地址处压栈 &lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=OrageRed&gt;&lt;em&gt;小端模式&lt;/em&gt; &lt;/font&gt;下的内存分配格局：
&lt;img alt="test" src="/images/cpp_stack_da.gif" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=OrageRed&gt;&lt;em&gt;大端模式&lt;/em&gt; &lt;/font&gt;下的内存分配格局：
&lt;img alt="test" src="/images/cpp_stack_xiao.jpg" /&gt;&lt;/p&gt;</summary><category term="code"></category></entry><entry><title>虚函数</title><link href="http://blog.zzfanhero.info/articles/xu-han-shu.html" rel="alternate"></link><updated>2016-03-07T00:00:00+08:00</updated><author><name>zzfan</name></author><id>tag:blog.zzfanhero.info,2016-03-07:articles/xu-han-shu.html</id><summary type="html"></summary><category term="code"></category></entry></feed>