<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>赵志凡'Blog</title><link href="http://blog.zzfanhero.info/" rel="alternate"></link><link href="http://blog.zzfanhero.info/feeds/coding.atom.xml" rel="self"></link><id>http://blog.zzfanhero.info/</id><updated>2016-03-19T00:00:00+08:00</updated><entry><title>线程池</title><link href="http://blog.zzfanhero.info/articles/xian-cheng-chi.html" rel="alternate"></link><updated>2016-03-19T00:00:00+08:00</updated><author><name>zzfan</name></author><id>tag:blog.zzfanhero.info,2016-03-19:articles/xian-cheng-chi.html</id><summary type="html"></summary><category term="code"></category></entry><entry><title>树（B,B-,B+,B\*）</title><link href="http://blog.zzfanhero.info/articles/shu-bb-bb.html" rel="alternate"></link><updated>2016-03-17T00:00:00+08:00</updated><author><name>zzfan</name></author><id>tag:blog.zzfanhero.info,2016-03-17:articles/shu-bb-bb.html</id><summary type="html"></summary><category term="数据结构"></category></entry><entry><title>进程和线程</title><link href="http://blog.zzfanhero.info/articles/jin-cheng-he-xian-cheng.html" rel="alternate"></link><updated>2016-03-16T00:00:00+08:00</updated><author><name>zzfan</name></author><id>tag:blog.zzfanhero.info,2016-03-16:articles/jin-cheng-he-xian-cheng.html</id><summary type="html">&lt;p&gt;进程，是并发执行的程序再执行过程中分配和管理资源的基本单位，是一个动态概念，竞争计算机系统资源的基本单位．每一个基础南横都有一个自己的地址空间，即进程空间或需空间．进程空间的大小只与处理机的位数有关．进程至少有５种状态，他们是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;初始态，执行态，等待状态，就绪状态，终止状态&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;线程，再网络或多用户环境下，一个服务器通常需要接收大量且不确定数量用户的并发请求，为每一个请求都创建一个进程显然使行不通的．因此操作系统中线程的概念便被引进了．线程，是进程的一部分，一个没有线程的进程可以被看做是单线程的．线程有时又被称为轻权进程或轻量级进程，也是ＣＰＵ调度的一个基本单位．&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;进程的执行过程是线状的&lt;/em&gt;&lt;/strong&gt;,尽管中间会发生终端或暂停，但该进程所拥有的资源只为该线状执行过程服务．一旦发生进程上下文切换，这些资源都是要被保护起来的．这是宏观上的执行过程．而进程又可有单线程进程与多鲜橙进程两种．&lt;strong&gt;&lt;em&gt;线程的改变只代表了cpu执行过程的改变而没有发生进程所拥有的资源变化，进程拥有一个完整的虚拟地址空间，布衣赖域线程而独立存在；反之，线程是进程的一部分，没有自己的地址空间，域进程内的其他线程一起共享分配该进程的所有资源&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;线程的执行特性&lt;br /&gt;
　线程只有３个基本状态：就绪，执行，阻塞．&lt;br /&gt;
　线程存在５种基本操作来切换线程的状态：派生，阻塞，激活，调度，结束．  &lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进程通信  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;主从式：终端控制进程和终端进程
会话式：用户进程域磁盘管理进程之间的通信
管道
共享内存
两个进程职位的内存快，两个进程均可以访问
锁机制
套接字
信号&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;线程间通信&lt;br /&gt;
锁机制：互斥锁／条件变量／读写锁&lt;br /&gt;
信号量&lt;br /&gt;
信号机制  &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary><category term="system"></category></entry><entry><title>堆栈以及大小端解析</title><link href="http://blog.zzfanhero.info/articles/dui-zhan-yi-ji-da-xiao-duan-jie-xi.html" rel="alternate"></link><updated>2016-03-08T00:00:00+08:00</updated><author><name>zzfan</name></author><id>tag:blog.zzfanhero.info,2016-03-08:articles/dui-zhan-yi-ji-da-xiao-duan-jie-xi.html</id><summary type="html">&lt;h3&gt;简介&lt;/h3&gt;
&lt;p&gt;在程序的设计中，都会设计堆栈的使用，其中堆使通过用户来调用的内存空间，需要用户主动分配和释放，如果只分配而不立即释放，则可能出现内存泄露的问题，其结果是难以估量的；
栈使系统自动调用的内存空间，系统也会根据实际情况自动去释放该空间．&lt;/p&gt;
&lt;p&gt;在平时的使用当中，我们需要注意堆栈的增长方向，一般来说，当堆栈指针（栈顶）由高地址向低地址增长时，我们称为向下增长；当堆栈指针（栈顶）由低地址向高地址增长时，我们称为向上增长．&lt;/p&gt;
&lt;p&gt;当然在程序设计中我们还需要注意的就是数据存储的方式：&lt;font color=OrangeRed&gt;大端存储／小端存储 &lt;/font&gt;．&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;大端存储--数据的高位字节保存再内存的低地址中，而数据的低位字节保存在内存的高地址中，这样的存储模式有点类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放;&lt;br /&gt;
  小端存储--数据的高位字节保存再内存的高地址中，而数据的低位字节保存在内存的低地址中，和我们的逻辑方式一致．  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;大小端测试方法&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;这是一个面试题  &lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%d,%d,%d&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;输出结果是什么？（32位环境，cpu为小端模式，所有参数用栈传递）&lt;br /&gt;
&lt;font color=Orange&gt;无论是在32/64环境中long long都是８个字节，参数从右到左进栈，栈中从栈底到栈顶依次为c/b/a，％d将打印栈中的４个字节，又因为是小端模式，所以打印结果为: 1 0 2&lt;/font&gt;   &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第二题  &lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mh"&gt;0x1234&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;=*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在32位大端模式处理器上变量b=?&lt;br /&gt;
&lt;font color=Orange&gt;大端存储，从低地址到高地址存储的为0x34、0x12，b指针指向a的第一个字节即0x34，0x34转换为ascii为0，所以输出结果为0.&lt;/font&gt;&lt;/p&gt;
&lt;h3&gt;分析&lt;/h3&gt;
&lt;p&gt;&lt;font color=Orange&gt;小端模式下，因为高地址再上，所以栈往低地址处延伸．所以先把先来者往低地址处压栈，再把后来者往高地址处压栈. 大端模式，因为低地址在上，所以栈往高低脂外延伸．所以先把先来者往高地址处压栈，再把后来者往低地址处压栈 &lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=OrageRed&gt;&lt;em&gt;小端模式&lt;/em&gt; &lt;/font&gt;下的内存分配格局：
&lt;img alt="test" src="/images/cpp_stack_da.gif" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=OrageRed&gt;&lt;em&gt;大端模式&lt;/em&gt; &lt;/font&gt;下的内存分配格局：
&lt;img alt="test" src="/images/cpp_stack_xiao.jpg" /&gt;&lt;/p&gt;</summary><category term="code"></category></entry><entry><title>虚函数</title><link href="http://blog.zzfanhero.info/articles/xu-han-shu.html" rel="alternate"></link><updated>2016-03-07T00:00:00+08:00</updated><author><name>zzfan</name></author><id>tag:blog.zzfanhero.info,2016-03-07:articles/xu-han-shu.html</id><summary type="html"></summary><category term="code"></category></entry></feed>