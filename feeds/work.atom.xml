<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>赵志凡'Blog</title><link href="http://blog.zzfanhero.info/" rel="alternate"></link><link href="http://blog.zzfanhero.info/feeds/work.atom.xml" rel="self"></link><id>http://blog.zzfanhero.info/</id><updated>2016-04-19T00:00:00+08:00</updated><entry><title>阿里笔试题总结--牛客网1</title><link href="http://blog.zzfanhero.info/articles/a-li-bi-shi-ti-zong-jie-niu-ke-wang-1.html" rel="alternate"></link><updated>2016-04-19T00:00:00+08:00</updated><author><name>zzfan</name></author><id>tag:blog.zzfanhero.info,2016-04-19:articles/a-li-bi-shi-ti-zong-jie-niu-ke-wang-1.html</id><summary type="html">&lt;p&gt;&lt;font size=4 color=Green&gt;摘要：明天阿里实习笔试，感觉还是做一些选择题压压惊....虽然我不去实习，但是这个很关键。&lt;/font&gt;  &lt;/p&gt;
&lt;h4&gt;1. 线程间通讯机制中，关键路径上不会产生系统调用从而减少用户态到内核态的上下文切换的是。&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;pthread_spin_lock&lt;/code&gt;:&lt;br /&gt;
spinlock又称自旋锁，线程通过busy-wait-loop的方式来获取锁，任时刻只有一个线程能够获得锁，其他线程忙等待直到获得锁。spinlock在多处理器多线程环境的场景中有很广泛的使用，一般要求使用spinlock的临界区尽量简短，这样获取的锁可以尽快释放，以满足其他忙等的线程。Spinlock和mutex不同，spinlock不会导致线程的状态切换(用户态-&amp;gt;内核态)，但是spinlock使用不当(如临界区执行时间过长)会导致cpu busy飙高。  &lt;/p&gt;
&lt;p&gt;pthread_mutex、信号量、pthread_rwlock、管道、消息队列  &lt;/p&gt;
&lt;h4&gt;2. 构造函数中，成员变量一定要通过初始化列表来初始化的是.&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt; {
    ...
    &lt;span class="n"&gt;private&lt;/span&gt;：
       &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="nv"&gt;&amp;amp;a&lt;/span&gt;;

};
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt; : &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt; {
    ...
    &lt;span class="n"&gt;private:&lt;/span&gt;
         &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;;
    &lt;span class="n"&gt;public:&lt;/span&gt;
         &lt;span class="n"&gt;const&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;;
         &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;;
         &lt;span class="n"&gt;static&lt;/span&gt; &lt;span class="n"&gt;const&lt;/span&gt; &lt;span class="n"&gt;char&lt;/span&gt;* &lt;span class="n"&gt;d&lt;/span&gt;;
         &lt;span class="n"&gt;A&lt;/span&gt;* &lt;span class="nb"&gt;e&lt;/span&gt;;

};
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;解析：b、c&lt;br /&gt;
构造函数初始化时必须采用初始化列表一共有三种情况， &lt;br /&gt;
1.需要初始化的数据成员是对象(继承时调用基类构造函数) &lt;br /&gt;
2.需要初始化const修饰的类成员 &lt;br /&gt;
3.需要初始化引用成员数据  &lt;/p&gt;
&lt;h4&gt;3. 互斥锁和排它锁&lt;/h4&gt;
&lt;p&gt;问题：进程P1和P2，资源A和B，进程对资源的操作定义如下：读取资源A：rA读取资源B：rB写入资源A：wA写入资源B：wB同时规定，进程读取某一资源前，必须加上共享锁，写入某一资源前必须加上排他锁；资源在被进程加共享锁时，可以被其他进程继续加共享锁，但不能加排他锁；资源在被进程加排他锁时，其他进程无法加锁。进程完成全部操作后释放锁。进程P1和进程P2并发执行，如下哪种运行序列可能会出现死锁。  &lt;/p&gt;
&lt;p&gt;解析：&lt;code&gt;P1(wB-&amp;gt;rA), P2(wA-&amp;gt;rB)&lt;/code&gt;&lt;br /&gt;
产生死锁的四个必要条件：&lt;br /&gt;
资源独占&lt;br /&gt;
不可剥夺&lt;br /&gt;
请求和保持&lt;br /&gt;
循环等待  &lt;/p&gt;
&lt;h4&gt;4. 快排算法效率最低&lt;/h4&gt;
&lt;p&gt;初始序列有序时，快速排序效率最低。  &lt;/p&gt;
&lt;h4&gt;5. 堆排序&lt;/h4&gt;
&lt;p&gt;问题：将整数数组（7-6-3-5-4-1-2）按照堆排序的方式原地进行升序排列，请问在第一轮排序结束之后，数组的顺序。  &lt;/p&gt;
&lt;p&gt;解析：&lt;code&gt;6-5-3-2-4-1-7&lt;/code&gt;&lt;br /&gt;
    1 2 3 4 5 6 7&lt;br /&gt;
    7 6 3 5 4 1 2&lt;br /&gt;
    2 6 3 5 4 1 7&lt;br /&gt;
    6 2 3 5 4 1 7&lt;br /&gt;
    6 5 3 2 4 1 7&lt;br /&gt;
构建最大堆的过程如上所示：&lt;br /&gt;
1.先把堆顶元素和末尾数交换&lt;br /&gt;
2.然后对前面的数进行最大堆调整  &lt;/p&gt;
&lt;h4&gt;6. 很有意思的一道题&lt;/h4&gt;
&lt;p&gt;问题：  函数func的定义如下：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;void&lt;/span&gt; &lt;span class="nt"&gt;func&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;const&lt;/span&gt; &lt;span class="nt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="nt"&gt;v1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;cont&lt;/span&gt; &lt;span class="nt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="nt"&gt;v2&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;v1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39; &amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;v2&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39; &amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在Visual Studio开发环境下， 以下代码输出结果为  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int main (int argc, char* argv[])
{
    int i=0;
    func(++i,i++);
    return 0;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;解析：2、0&lt;br /&gt;
此题的关键在于i++和++i的区别。&lt;br /&gt;
i++返回的是一个临时变量，且 i = i + 1;&lt;br /&gt;
++i返回的是i本事，且 i = i + 1。&lt;br /&gt;
&lt;code&gt;void func(constint&amp;amp; v1, cont int&amp;amp; v2)&lt;/code&gt;  &lt;br /&gt;
这个函数中，首先v2传入的是临时变量的别名。&lt;br /&gt;
然后v1传入的i的别名;  所以，调用函数中v1指的是i,v2指的是临时变量。&lt;br /&gt;
然后就是i++和++i的计算顺序问题。&lt;br /&gt;
虽然传入参数的顺序是从右到左的，但是参数的计算顺序却是未确定的。&lt;br /&gt;
所以，如果先计算i++, 再计算++i；则结果为2， 0&lt;br /&gt;
如果先计算++i, 再计算i++; 则结果应该是2， 1  &lt;/p&gt;
&lt;h4&gt;7. 森林和二叉树的转换&lt;/h4&gt;
&lt;p&gt;问题：将森林转换为对应的二叉树，若在二叉树结点中，结点m是结点n的双亲结点的双亲结点，则在原来的森林中，m和n可能具有的关系是&lt;br /&gt;
1.父子关系 &lt;br /&gt;
2.m的双亲结点与n的双亲结点是兄弟关系&lt;br /&gt;
3.兄弟关系  &lt;/p&gt;
&lt;p&gt;解析：1、3  &lt;/p&gt;
&lt;h4&gt;8. 博弈论&lt;/h4&gt;
&lt;p&gt;&lt;font color=Red&gt;但是溪老师讲博弈论，我没去听，发现真的很有用啊&lt;/font&gt;&lt;br /&gt;
题目：16个石子一次可以拿1,3,6个，取到最后一个的人必胜，先手拿几个必胜?两个人拿。  &lt;/p&gt;
&lt;p&gt;解析：显然0的时候是必败点，看1，只能选择拿走1个，变成0,0是必败点，所以1是必胜点，然后看2,2的下一步只能选择拿走1个变成1,1是必胜点;2只能到达必胜点，所以2是必败点;3的下一步2和0都是必败点，所以3是必胜点;4的下一步3、1都是必胜点，所以4是必败点；5的下一步4、2都是必败点，所以5是必胜点；6的下一步5\3\0，0是必败点，所以6是必胜点；7的下一步6\4\1,4是必败点，所以7是必胜点；8的下一步是7\4\2,4和2都是必败点，所以8是必胜点；9的下一步是8\6\3,8\6\3都是必胜点，所以9是必败点；10下一步9\7\4，必胜点；11下一步10\8\5，都是必胜点，所以11是必败点；12下一步11\9\6,11和9都是必败点，所以12是必胜点；13(12,10,7)，都是必胜点，所以13是必败点；由此类推。&lt;br /&gt;
先手拿3个最好。  &lt;/p&gt;
&lt;p&gt;题目：两人在一个n个点的无向完全图上进行游戏，每次可以选择当前图中两个端点度数奇偶性相同的边删除，谁不能操作谁输，则在n=1,2,3,......,9,10中，有____个图先手有必胜策略。  &lt;/p&gt;
&lt;p&gt;解析：N个点的无向完全图边数为：N*（N-1）/2；先手获胜必须总数为奇数；&lt;br /&gt;
N=1,2,3,......,9,10代入公式，为奇数的只有N=2,3,6,7,10这5个。  &lt;/p&gt;
&lt;h4&gt;9. 缺省参数静态绑定&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;class&lt;/span&gt; &lt;span class="nt"&gt;A&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="n"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;virtual&lt;/span&gt; &lt;span class="n"&gt;void&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;int&lt;/span&gt; &lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="err"&gt;{&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;A-&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;
    &lt;span class="nt"&gt;virtual&lt;/span&gt; &lt;span class="nt"&gt;void&lt;/span&gt; &lt;span class="nt"&gt;test&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;();}&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="nt"&gt;class&lt;/span&gt; &lt;span class="nt"&gt;B&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nt"&gt;public&lt;/span&gt; &lt;span class="nt"&gt;A&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="n"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;void&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;int&lt;/span&gt; &lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;B-&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="nt"&gt;int&lt;/span&gt; &lt;span class="nt"&gt;main&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;int&lt;/span&gt; &lt;span class="nt"&gt;argc&lt;/span&gt; &lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="nt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nt"&gt;argv&lt;/span&gt;&lt;span class="cp"&gt;[]&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;return&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;输出为：&lt;code&gt;B-&amp;gt;1&lt;/code&gt;  &lt;/p&gt;
&lt;h4&gt;10. 进程和线程&lt;/h4&gt;
&lt;p&gt;同一个进程的线程之间共享内存和堆，但不共享栈  &lt;/p&gt;
&lt;h4&gt;11. 智力题&lt;/h4&gt;
&lt;p&gt;题目：如果我国希望在３０年后实现经济翻翻，并且假设我国经济增长速度每年都保持相同，那么至少需要每年保持____增长速度才可实现目标。  &lt;/p&gt;
&lt;p&gt;解析：&lt;code&gt;A(1+X%)^30=2A&lt;/code&gt;  &lt;/p&gt;
&lt;h4&gt;11. 折半查找&lt;/h4&gt;
&lt;p&gt;题目：下面是折半查找的实现，data是按升序排列的数据，x是查找下标，y是查找的上标，
v是查找的数值，返回v在data的索引，若没找到返回-1。代码不正确是：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;public int bsearch(int[] data, int x, int y, int v) {
    int m;
    while(x&amp;lt;y){ //1
        m = x + (y-x)/2; //2
        if(data[m] == v) return m; //3
        else if(data[m] &amp;gt; v) y = m; //4
        else x = m; //5
    }
    return -1; //6
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;解析：上下标没有写清楚，题目所指的应该是[x,y),这样5应该是m-1
而在下标为[x,y]的情况下，1,4,5都是有问题的。。。。正确版本应该是这样吧  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;while(x&amp;lt;=y) {
        m = x + (y-x)/2; //2
        if(data[m] == v) return m; //3
        else if(data[m] &amp;gt; v) y = m-1; //4
        else x = m+1; //5
    }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;补充：这里下标是个坑，记住上限有没有包含就可以对付1,4,5处的问题（熟记理解两个版本的代码区别），然后是2，写成x+(y-x)/2是防止xy都很大的情况下x+y越界。这样的话应对二分查找应该够了  &lt;/p&gt;
&lt;h4&gt;12. 概率题&lt;/h4&gt;
&lt;p&gt;题目：商品推荐场景中过于聚焦的商品推荐往往会损害用户的购物体验，在有些场景中，系统会通过一定程度的随机性给用户带来发现的惊喜感。假设在某推荐场景中，经计算A和B两个商品与当前访问用户的匹配度分别为0.8和0.2分，系统将随机为A生成一个均匀分布于0到0.8的最终得分，为B生成一个均匀分布于0到0.2的最终得分，那么最终B的分数大于A的分数的概率为_____。  &lt;/p&gt;
&lt;p&gt;解析：&lt;code&gt;(0.2&lt;em&gt;0.2)/2/(0.8&lt;/em&gt;0.2)&lt;/code&gt;  &lt;/p&gt;
&lt;h4&gt;* 组合数学&lt;/h4&gt;
&lt;p&gt;题目：从1,2,3,4...8,9里任意选择一部分数(至少1个),能得到多少种不同的乘积  &lt;/p&gt;
&lt;p&gt;解析：分解因子: &lt;code&gt;1&lt;em&gt;2&lt;/em&gt;...&lt;em&gt;9=2^7  * 3^4  * 5  * 7&lt;/code&gt;&lt;br /&gt;
总=&lt;code&gt;8&lt;/em&gt;5&lt;em&gt;2&lt;/em&gt;2=160&lt;/code&gt;
但 &lt;code&gt;2^7 * 3^0&lt;/code&gt; 和 &lt;code&gt;2^0 * 3^4&lt;/code&gt; 这两种情况不存在，5和7的组合是4种
所以答案=&lt;code&gt;160- 2*4 = 152&lt;/code&gt;  &lt;/p&gt;</summary><category term="笔试"></category><category term="面试"></category><category term="选择题"></category></entry><entry><title>输出数组中第k小的数</title><link href="http://blog.zzfanhero.info/articles/shu-chu-shu-zu-zhong-di-kxiao-de-shu.html" rel="alternate"></link><updated>2016-04-19T00:00:00+08:00</updated><author><name>zzfan</name></author><id>tag:blog.zzfanhero.info,2016-04-19:articles/shu-chu-shu-zu-zhong-di-kxiao-de-shu.html</id><summary type="html">&lt;p&gt;&lt;font size=4 color=Green&gt;摘要：今天忙了一天出国参加ICC的事，好烦，突然就想为什么我们要选这种专业，我们付出的比别人要多，最后只能成为螺丝钉，我们的智商如果用在别处还需要这么累吗。只是为了心中那莫名的进取心一步一步的进入了这个坑。&lt;/font&gt;  &lt;/p&gt;
&lt;h3&gt;* 题目描述&lt;/h3&gt;
&lt;p&gt;快速输出第k小的数。  &lt;/p&gt;
&lt;h3&gt;* 思路&lt;/h3&gt;
&lt;p&gt;使用快速排序的思想，递归求解。若键值位置i与k相等，返回。若大于k，则在&lt;code&gt;[start, i-1]&lt;/code&gt;中寻找第k大的数。若小于则在&lt;code&gt;[i+1, end]&lt;/code&gt;中寻找第&lt;code&gt;k+start-1&lt;/code&gt;小的数。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/*************************************************************************&lt;/span&gt;
&lt;span class="cm"&gt;    &amp;gt; File Name: choose.cpp&lt;/span&gt;
&lt;span class="cm"&gt;    &amp;gt; Author: zzfan&lt;/span&gt;
&lt;span class="cm"&gt;    &amp;gt; Mail: zzfan@mail.ustc.edu.cn &lt;/span&gt;
&lt;span class="cm"&gt;    &amp;gt; Created Time: Tue 19 Apr 2016 04:41:43 PM HKT&lt;/span&gt;
&lt;span class="cm"&gt; ************************************************************************/&lt;/span&gt;

&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;choose&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;end&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="nf"&gt;end&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;end&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;choose&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nf"&gt;end&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;choose&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
    &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;choose&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;font size=4 color=Red&gt;分析：这个题目还是很有意思的,用到了快排的思想&lt;/font&gt;  &lt;/p&gt;</summary><category term="面试"></category><category term="笔试"></category></entry><entry><title>深度优先搜索算法（DFS）</title><link href="http://blog.zzfanhero.info/articles/shen-du-you-xian-sou-suo-suan-fa-dfs.html" rel="alternate"></link><updated>2016-04-17T00:00:00+08:00</updated><author><name>zzfan</name></author><id>tag:blog.zzfanhero.info,2016-04-17:articles/shen-du-you-xian-sou-suo-suan-fa-dfs.html</id><summary type="html">&lt;p&gt;&lt;font size=4 color=Green&gt;（13）摘要：做leetcode遇到了Ksum的问题，用这个很方便。&lt;/font&gt;  &lt;/p&gt;
&lt;h3&gt;* Pre&lt;/h3&gt;
&lt;p&gt;深度优先搜索（缩写DFS）有点类似广度优先搜索，也是对一个连通图进行遍历的算法。它的思想是从一个顶点V0开始，沿着一条路一直走到底，如果发现不能到达目标解，那就返回到上一个节点，然后从另一条路开始走到底，这种尽量往深处走的概念即是深度优先的概念。  &lt;/p&gt;
&lt;h4&gt;* 搜索过程&lt;/h4&gt;
&lt;p&gt;找出一条V0到V6的道路，而无需最短路。&lt;br /&gt;
&lt;img alt="dfs1" src="/images/dfs/1.png" /&gt;  &lt;/p&gt;
&lt;p&gt;假设按照以下的顺序来搜索：&lt;br /&gt;
1.&lt;code&gt;V0-&amp;gt;V1-&amp;gt;V4&lt;/code&gt;，此时到底尽头，仍然到不了&lt;code&gt;V6&lt;/code&gt;，于是原路返回到V1去搜索其他路径；&lt;br /&gt;
2.返回到V1后既搜索V2，于是搜索路径是&lt;code&gt;V0-&amp;gt;V1-&amp;gt;V2-&amp;gt;V6&lt;/code&gt;，找到目标节点，返回有解。&lt;br /&gt;
这样搜索只是2步就到达了，但是如果用BFS的话就需要多几步。  &lt;/p&gt;
&lt;h4&gt;* further&lt;/h4&gt;
&lt;p&gt;&lt;img alt="dfs2" src="/images/dfs/2.png" /&gt;&lt;br /&gt;
求图中的V0出发，是否存在一条路径长度为4的搜索路径。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/*************************************************************************&lt;/span&gt;
&lt;span class="cm"&gt;    &amp;gt; File Name: dfs.cpp&lt;/span&gt;
&lt;span class="cm"&gt;    &amp;gt; Author: zzfan&lt;/span&gt;
&lt;span class="cm"&gt;    &amp;gt; Mail: zzfan@mail.ustc.edu.cn &lt;/span&gt;
&lt;span class="cm"&gt;    &amp;gt; Created Time: Sun 17 Apr 2016 11:00:24 AM HKT&lt;/span&gt;
&lt;span class="cm"&gt; ************************************************************************/&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

memset&lt;span class="o"&gt;(&lt;/span&gt;visit&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;n&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

bool&lt;span class="w"&gt; &lt;/span&gt;DFS&lt;span class="o"&gt;(&lt;/span&gt;Node&lt;span class="w"&gt; &lt;/span&gt;n&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;int&lt;span class="w"&gt; &lt;/span&gt;d&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kr"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;d&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;4&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kr"&gt;return&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;true&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kr"&gt;for&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;nextNode&lt;span class="w"&gt; &lt;/span&gt;in&lt;span class="w"&gt; &lt;/span&gt;n&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kr"&gt;if&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="err"&gt;!&lt;/span&gt;visit&lt;span class="err"&gt;[&lt;/span&gt;nextNode&lt;span class="err"&gt;]&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;visit&lt;span class="err"&gt;[&lt;/span&gt;nextNode&lt;span class="err"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;true&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="kr"&gt;if&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;DFS&lt;span class="o"&gt;(&lt;/span&gt;nextNode&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;d&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="kr"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;true&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;visit&lt;span class="err"&gt;[&lt;/span&gt;nextNode&lt;span class="err"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;false&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kr"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;false&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;* 24点&lt;/h4&gt;
&lt;p&gt;很经典的一个题目：&lt;br /&gt;
想必大家都玩过一个游戏，叫做“24点”：给出4个整数，要求用加减乘除4个运算使其运算结果变成24，4个数字要不重复的用到计算中。&lt;br /&gt;
例如给出4个数：1、2、3、4。我可以用以下运算得到结果24： &lt;br /&gt;
&lt;code&gt;1&lt;em&gt;2&lt;/em&gt;3&lt;em&gt;4 = 24；2&lt;/em&gt;3&lt;em&gt;4/1 = 24；(1+2+3)&lt;/em&gt;4=24&lt;/code&gt;；…… &lt;br /&gt;
如上，是有很多种组合方式使得他们变成24的，当然也有无法得到结果的4个数，例如：1、1、1、1。&lt;br /&gt;
现在我给你这样4个数，你能告诉我它们能够通过一定的运算组合之后变成24吗？这里我给出约束：数字之间的除法中不得出现小数，例如原本我们可以1/4=0.25，但是这里的约束指定了这样操作是不合法的。&lt;br /&gt;
&lt;font size=4 color=Red&gt;分析：其实在不知道这个方法之前我遇到这种题是一点头绪都没有，之前也学过搜索树，但是觉得那个我一直没有用到，所以对那个也没有太多的概念.但是遇到这题之后总算是有点头绪了，相信慢慢的积累还是有用的。现在我也想重新看一次Unix网络编程这本书，把网络方面的基础知识过一遍，虽然自己现在在看内核，但是用户态的东西如果不是很清晰的话有些地方会有些迷惑（虽然我觉得我现在对IP网络以及未来网络的理解已经突破天际了，哈哈）。&lt;/font&gt;  &lt;/p&gt;</summary><category term="笔试"></category><category term="面试"></category></entry><entry><title>AF_INET和PF_INET的区别</title><link href="http://blog.zzfanhero.info/articles/af_inethe-pf_inetde-qu-bie.html" rel="alternate"></link><updated>2016-04-06T00:00:00+08:00</updated><author><name>zzfan</name></author><id>tag:blog.zzfanhero.info,2016-04-06:articles/af_inethe-pf_inetde-qu-bie.html</id><summary type="html">&lt;p&gt;&lt;font size=4 color=Green&gt;摘要：刚写了一个原始套接字发送ipv6包的程序，平时一直用的 AF_INET协议簇，一直没有在意这些，感觉还是要总结下的。&lt;/font&gt;  &lt;/p&gt;
&lt;p&gt;在写网络程序的时候，建立TCP socket：&lt;br /&gt;
 socket = socket(PF_INET, SOCK_STREAM, 0);  &lt;/p&gt;
&lt;p&gt;然后再绑定本地地址或连接远程地址时需要初始化&lt;code&gt;sockaddr_in&lt;/code&gt;结构，其中指定&lt;code&gt;address family&lt;/code&gt;时一般设置为AF_INET，即使用IP。&lt;br /&gt;
相关的头文件的定义：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;AF = Address family
PF = Protocol Family  
AF_INET = PF_INET  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在Windows中的&lt;code&gt;insock2.h&lt;/code&gt;中，  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;#define AF_INET 0
#define PF_INET AF_INET  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;所以在windows中AF_INET与PF_INET完全一样。  &lt;/p&gt;
&lt;p&gt;而在Unix/Linux系统中，在不通过的版本中这两者有微小差别，对于BSD，是AF，对于POSIX是PF。&lt;br /&gt;
理论上建立socket时是指定协议，应该用PF_xxxx，设置地址时应该用AF_xxxx。当然AF_INET和PF_INET的值是相同的，混用也不会有太大的问题。也就是说你socket时候用PF_xxxx，设置的时候用AF_xxxx也是没关系的，这点随便找个TCP/IP例子就可以验证出来了。如下，不论是AF_INET还是PF_INET都是可行的，只不过这样子的话，有点不符合规范。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="err"&gt;服务端开始建立&lt;/span&gt;&lt;span class="nt"&gt;socket&lt;/span&gt;&lt;span class="err"&gt;描述符&lt;/span&gt;
&lt;span class="nt"&gt;if&lt;/span&gt;&lt;span class="o"&gt;((&lt;/span&gt;&lt;span class="nt"&gt;sockfd&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nt"&gt;socket&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;PF_INET&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;SOCK_STREAM&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;0&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nt"&gt;-1&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;fprintf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stderr&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Socket error: %s\n&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;strerror&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="n"&gt;exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="err"&gt;服务器端填充&lt;/span&gt; &lt;span class="nt"&gt;sockaddr&lt;/span&gt;&lt;span class="err"&gt;结构&lt;/span&gt;
&lt;span class="nt"&gt;bzero&lt;/span&gt;&lt;span class="o"&gt;(&amp;amp;&lt;/span&gt;&lt;span class="nt"&gt;server_addr&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;sizeof&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;struct&lt;/span&gt; &lt;span class="nt"&gt;sockaddr_in&lt;/span&gt;&lt;span class="o"&gt;));&lt;/span&gt;
&lt;span class="nt"&gt;server_addr&lt;/span&gt;&lt;span class="nc"&gt;.sin_family&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nt"&gt;AF_INET&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="nt"&gt;server_addr&lt;/span&gt;&lt;span class="nc"&gt;.sin_family&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nt"&gt;PF_INET&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="nt"&gt;server_addr&lt;/span&gt;&lt;span class="nc"&gt;.sin_addr.s_addr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nt"&gt;htonl&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;INADDR_ANY&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="nt"&gt;server_addr&lt;/span&gt;&lt;span class="nc"&gt;.sin_port&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nt"&gt;htons&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;portnumber&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在函数socketpair与socket的domain参数中有：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;AF_UNIX, AF_LOCAL, AF_INET, PF_UNIX, PF_LOCAL, PF_INET.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这几个参数有：&lt;code&gt;AF_UNIX = AF_LOCAL, PF_UNIX = PF_LOCAL, AF_LOCAL = PF_LOCAL, AF_INET = PF_INET.&lt;/code&gt;&lt;br /&gt;
但是对于socketpair与socket的domain参数，使用PF_LOCAL系列，而在初始化套接口地址时，则使用AF_LOCAL.&lt;br /&gt;
例如：  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;z = socket(PF_LOCAL, SOCK_STREAM, 0);
adr_unix.sin_family = AF_LOCAL;&lt;/p&gt;
&lt;/blockquote&gt;</summary><category term="unp"></category><category term="面试"></category></entry><entry><title>字符串问题总结（持续更新中）</title><link href="http://blog.zzfanhero.info/articles/zi-fu-chuan-wen-ti-zong-jie-chi-xu-geng-xin-zhong.html" rel="alternate"></link><updated>2016-04-05T00:00:00+08:00</updated><author><name>zzfan</name></author><id>tag:blog.zzfanhero.info,2016-04-05:articles/zi-fu-chuan-wen-ti-zong-jie-chi-xu-geng-xin-zhong.html</id><summary type="html">&lt;p&gt;&lt;font size=4 color=Green&gt;摘要：感觉自己的编程功底还是不太够，一直练下去吧，坚持下去总会取得好的结果，人生没有什么不可能，虽然我已经很厉害了.....&lt;/font&gt;  &lt;/p&gt;
&lt;h3&gt;一、最长回文子序列&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;问题描述&lt;/em&gt;:给一个字符串，找出它的最长的回文子序列的长度。例如，如果给定的序列是“BBABCBCAB”，则输出应该是7，“BABCBAB”是在它的最长回文子序列。 “BBBBB”和“BBCBB”也都是该字符串的回文子序列，但不是最长的。&lt;font color=Red&gt;注意和最长回文子串的区别&lt;/font&gt;。  &lt;/p&gt;
&lt;p&gt;&lt;em&gt;解决方案&lt;/em&gt;:&lt;br /&gt;
假设 X[0 ... n-1]  是给定的序列，长度为n.  让 L(0,n-1) 表示 序列 X[0 ... n-1] 的最长回文子序列的长度。  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;如果X的最后一个元素和第一个元素是相同的，这时：L(0, n-1) = L(1, n-2) + 2 ,  还以 “BBABCBCAB” 为例，第一个和最后一个相同，因此 L(1,n-2) 就表示蓝色的部分。  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果不相同：L(0, n-1) = MAX ( L(1, n-1) ,  L(0, n-2)  )。 以”BABCBCA” 为例，L(1,n-1)即为去掉第一个元素的子序列，L(0, n-2)为去掉最后一个元素。  &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有了上面的公式，可以很容易的写出下面的递归程序：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/*************************************************************************&lt;/span&gt;
&lt;span class="cm"&gt;    &amp;gt; File Name: test.cpp&lt;/span&gt;
&lt;span class="cm"&gt;    &amp;gt; Author: zzfan&lt;/span&gt;
&lt;span class="cm"&gt;    &amp;gt; Mail: zzfan@mail.ustc.edu.cn &lt;/span&gt;
&lt;span class="cm"&gt;    &amp;gt; Created Time: Tue 05 Apr 2016 02:36:47 PM HKT&lt;/span&gt;
&lt;span class="cm"&gt; ************************************************************************/&lt;/span&gt;

&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;lps&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;lps&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nf"&gt;max&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lps&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;lps&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cin&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;size&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;lps&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;font size=4 color=Red&gt;注意：还是要熟悉下递归的用法吧。&lt;/font&gt;  &lt;/p&gt;
&lt;h3&gt;二、最长回文子串&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;题目描述:&lt;/em&gt;给定一个字符串，求它的最长回文子串的长度。  &lt;/p&gt;
&lt;p&gt;&lt;em&gt;分析与解法：&lt;/em&gt;最容易想到的办法是枚举所有的子串，分别判断其是否为回文。这个思路初看起来是正确的，但却做了很多无用功，如果一个长的子串包含另一个短一些的子串，那么对子串的回文判断其实是不需要的。  &lt;/p&gt;
&lt;p&gt;&lt;em&gt;解法一：&lt;/em&gt;&lt;br /&gt;
不需要做过多的无用功，那么我们可以枚举中心位置，然后再在该位置上用扩展法，记录并更新得到的最长的回文长度。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/*************************************************************************&lt;/span&gt;
&lt;span class="cm"&gt;    &amp;gt; File Name: longestPalindromic.cpp&lt;/span&gt;
&lt;span class="cm"&gt;    &amp;gt; Author: zzfan&lt;/span&gt;
&lt;span class="cm"&gt;    &amp;gt; Mail: zzfan@mail.ustc.edu.cn &lt;/span&gt;
&lt;span class="cm"&gt;    &amp;gt; Created Time: Tue 05 Apr 2016 03:31:22 PM HKT&lt;/span&gt;
&lt;span class="cm"&gt; ************************************************************************/&lt;/span&gt;

&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;longestPalindromic&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;max&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;size&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;len&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nf"&gt;max&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="c1"&gt;//对于奇数的情况&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="c1"&gt;//对于偶数的情况&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nf"&gt;max&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
            &lt;span class="nf"&gt;max&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nf"&gt;max&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cin&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Longest Prindromic: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;longestPalindromic&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;font size=4 color=Red&gt;注意：分奇数偶数的情况，如果回文的定义不一样也不一样&lt;/font&gt;  &lt;/p&gt;</summary><category term="笔试"></category><category term="面试"></category><category term="字符串"></category></entry><entry><title>堆 栈 静态区 常量区</title><link href="http://blog.zzfanhero.info/articles/dui-zhan-jing-tai-qu-chang-liang-qu.html" rel="alternate"></link><updated>2016-03-30T00:00:00+08:00</updated><author><name>zzfan</name></author><id>tag:blog.zzfanhero.info,2016-03-30:articles/dui-zhan-jing-tai-qu-chang-liang-qu.html</id><summary type="html">&lt;p&gt;&lt;font size=4 color=Green&gt;摘要：一个由c/C++编译的程序占用内存分为以下几个部分，刚才突然看到的。&lt;/font&gt;  &lt;/p&gt;
&lt;p&gt;1、&lt;code&gt;栈区（stack）&lt;/code&gt;— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。  &lt;/p&gt;
&lt;p&gt;2、&lt;code&gt;堆区（heap）&lt;/code&gt; — 一般由程序员分配释放 ， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。   &lt;/p&gt;
&lt;p&gt;3、&lt;code&gt;全局区（静态区）（static）&lt;/code&gt;—，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域(BSS)。 - 程序结束后由系统释放   &lt;/p&gt;
&lt;p&gt;4、&lt;code&gt;文字常量区&lt;/code&gt; — 常量字符串就是放在这里的。 程序结束后由系统释放   &lt;/p&gt;
&lt;p&gt;5、&lt;code&gt;程序代码区&lt;/code&gt; — 存放函数体的二进制代码。  &lt;/p&gt;</summary><category term="面试"></category><category term="笔试"></category></entry><entry><title>快速排序</title><link href="http://blog.zzfanhero.info/articles/kuai-su-pai-xu.html" rel="alternate"></link><updated>2016-03-30T00:00:00+08:00</updated><author><name>zzfan</name></author><id>tag:blog.zzfanhero.info,2016-03-30:articles/kuai-su-pai-xu.html</id><summary type="html">&lt;p&gt;&lt;font size=4 color=Green&gt;摘要：本来以为快排很好写，写出来了但是花了较长的时间，还是总结下吧，免得以后措手不及。&lt;/font&gt;  &lt;/p&gt;
&lt;h3&gt;* Typename和Class的区别&lt;/h3&gt;
&lt;p&gt;刚看到关于这两个的区别，这两个用于内置数据类型是是没有区别的，也都可以用于类，但当T是一个类，而这个类又有子类时（假设名为&lt;code&gt;innerClass&lt;/code&gt;），应该用&lt;code&gt;template&lt;typename&gt;&lt;/code&gt;:  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;typename&lt;/span&gt; &lt;span class="nt"&gt;T&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="nd"&gt;:innerClass&lt;/span&gt; &lt;span class="nt"&gt;myInnerObject&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里的&lt;code&gt;typename&lt;/code&gt;告诉编译器，&lt;code&gt;T::innerClass&lt;/code&gt; 是一个类，程序要声明一个 &lt;code&gt;T::innerClass&lt;/code&gt; 类的对象，而不是声明 T 的静态成员，而 typename 如果换成 class 则语法错误。  &lt;/p&gt;
&lt;h3&gt;* 快速排序&lt;/h3&gt;
&lt;p&gt;思想就不啰嗦了，快排的思想都不会就不要看这个了.....  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/*************************************************************************&lt;/span&gt;
&lt;span class="cm"&gt;    &amp;gt; File Name: quickSort.cpp&lt;/span&gt;
&lt;span class="cm"&gt;    &amp;gt; Author: zzfan&lt;/span&gt;
&lt;span class="cm"&gt;    &amp;gt; Mail: zzfan@mail.ustc.edu.cn &lt;/span&gt;
&lt;span class="cm"&gt;    &amp;gt; Created Time: Wed 30 Mar 2016 10:25:52 PM HKT&lt;/span&gt;
&lt;span class="cm"&gt; ************************************************************************/&lt;/span&gt;

&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;//方法一&lt;/span&gt;
&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;partition&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[],&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;temp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;quickSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[],&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;partition&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;quickSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;quickSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;//方法二&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Qsort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[],&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;low&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;high&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;low&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;high&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;low&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;last&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;high&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;last&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;last&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;last&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
            &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;last&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;last&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

        &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;last&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
            &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;last&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;Qsort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;low&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;Qsort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;high&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;57&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;68&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;59&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;52&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;72&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;28&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;96&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;33&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;24&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;

    &lt;span class="n"&gt;quickSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary><category term="笔试"></category><category term="面试"></category></entry><entry><title>leetcode难度及面试频率表</title><link href="http://blog.zzfanhero.info/articles/leetcodenan-du-ji-mian-shi-pin-lu-biao.html" rel="alternate"></link><updated>2016-03-29T00:00:00+08:00</updated><author><name>zzfan</name></author><id>tag:blog.zzfanhero.info,2016-03-29:articles/leetcodenan-du-ji-mian-shi-pin-lu-biao.html</id><summary type="html">&lt;p&gt;&lt;font size=4 color=Green&gt;摘要：不要问我为什么要看这个，我就是这么的俗....&lt;/font&gt;  &lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.csdn.net/yutianzuijin/article/details/11477603"&gt;leetcode难度及面试频率表&lt;/a&gt;  &lt;/p&gt;</summary><category term="面试"></category><category term="笔试"></category></entry><entry><title>面试链表问题(网易面试题总结)</title><link href="http://blog.zzfanhero.info/articles/mian-shi-lian-biao-wen-ti-wang-yi-mian-shi-ti-zong-jie.html" rel="alternate"></link><updated>2016-03-28T00:00:00+08:00</updated><author><name>zzfan</name></author><id>tag:blog.zzfanhero.info,2016-03-28:articles/mian-shi-lian-biao-wen-ti-wang-yi-mian-shi-ti-zong-jie.html</id><summary type="html">&lt;p&gt;&lt;font size=4 color=Green&gt;摘要：(10)链表问题在面试过程中也是很重要的也很基础的一部分，链表本身很灵活，很考查编程工地，所以是很值得考的地方。我将复习过程中觉得比较号的链表问题整理了一下。&lt;/font&gt;  &lt;/p&gt;
&lt;h3&gt;* 在O（1）时间删除链表节点&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;题目描述&lt;/em&gt;: 给定链表的头指针和一个节点指针，在O（1）时间删除该节点。[Google面试题]  &lt;/p&gt;
&lt;p&gt;&lt;em&gt;分析&lt;/em&gt;: 本题与《编程之美》上的[从无头单链表中删除节点]类似。主要思想都是[狸猫换太子]，即用下一个节点数据覆盖要删除的节点，然后删除下一个节点。但是如果节点是尾节点时，该方法就行不通了。  &lt;/p&gt;
&lt;p&gt;代码如下：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//O（1）时间删除链表节点，从屋头单链表中删除节点  
void deleteRandomNode(Node *cur)
{
    assert(cur != NULL);
    assert(cur-&amp;gt;next != NULL); //不能是尾节点
    Node* pNext = cur-&amp;gt;next;
    cur-&amp;gt;data = pNext-&amp;gt;dat;
    cur-&amp;gt;next = pNext-&amp;gt;next;
    delete pNext;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;* 单链表的转置&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;题目描述&lt;/em&gt;: 输入一个单项链表，输出逆序反转后的链表  &lt;/p&gt;
&lt;p&gt;&lt;em&gt;分析&lt;/em&gt;: 链表的转置事宜改革很常见的问题，费递归算法很简单，用三个临时指针pre/head/next在链表上循环一边即可。递归算法也是比较简单的，但是如果思路不清晰估计一时半会也写不出来把。  &lt;/p&gt;
&lt;p&gt;线面是玄幻版本和递归版本的链表转置代码：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//单链表的转置，循环方法  
Node* reverseByLoop(Node *head)
{
    if(head == NULL || head-&amp;gt;next == NULL){
        return head;
    }

    Node *pre = NULL;
    Node *next = NULL;
    while(head){
        next = head-&amp;gt;next;
        head-&amp;gt;next = pre;
        pre = head;
        head = next;
    }
    return pre;
}

//递归版本的单链表转置  
Node* reverseByRecursion(Node *head)
{
    //主要的思想就是从后面翻转
    if(head == NULL || head-&amp;gt;next == NULL){
        return head;
    }

    Node *newHead = reverseByRecursion(head-&amp;gt;next);

    head-&amp;gt;next-&amp;gt;next = head;
    head-&amp;gt;next = NULL;

    return newHead;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;* 求链表倒数第K个节点&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;题目描述&lt;/em&gt;: 输入一个单向链表，输出该链表中倒数第K个节点，链表的倒数第0个节点为链表的尾指针。  &lt;/p&gt;
&lt;p&gt;&lt;em&gt;分析&lt;/em&gt;: 设置两个指针p1/p2，首先p1和p2都指向head，然后p2向前走k步，这样p1和p2之间就间隔k个节点，然后p1和p2同时向前移动，直到p2走到链表末尾。  &lt;/p&gt;
&lt;p&gt;代码如下：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Node* theKthNode(Node *head, int k)
{
    if (k &amp;lt; 0) return NULL; //异常判断

    Node *slow,*fast;
    slow = fast = head;
    for(int i = k; i&amp;gt;0 &amp;amp;&amp;amp; fast!=NULL; i--){
        fast = fast-&amp;gt;next;
    }

    if(i &amp;gt; 0) return NULL; //k大于链表长度
    while(fast != NULL)
    {
        slow = slow-&amp;gt;next;
        fast = fast-&amp;gt;next;
    }

    return slow;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;*求链表中间节点&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;题目描述&lt;/em&gt;: 求链表的中间节点，如果链表的长度位偶数，返回中间两个节点任意一个，若为奇数，则返回中间节点。  &lt;/p&gt;
&lt;p&gt;&lt;em&gt;分析&lt;/em&gt;: 此题的解决思路和第3题「求链表的倒数第 k 个节点」很相似。可以先求链表的长度，然后计算出中间节点所在链表顺序的位置。但是如果要求只能扫描一遍链表，如何解决呢？最高效的解法和第3题一样，通过两个指针来完成。用两个指针从链表头节点开始，一个指针每次向后移动两步，一个每次移动一步，直到快指针移到到尾节点，那么慢指针即是所求。   &lt;/p&gt;
&lt;p&gt;代码如下：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Node* theMiddleNode(Node *head)
{
    if(head == NULL){
        return NULL;
    }
    Node *slow,*fast;
    slow = fast = head;
    //如果要求链表长度位偶数的情况下，返回中间两个节点的第一个，可以用下面的循环条件  
    //while(fast &amp;amp;&amp;amp; fast-&amp;gt;next != NULL &amp;amp;&amp;amp; fast-&amp;gt;next-&amp;gt;next != NULL)
    while(fast != NULL &amp;amp;&amp;amp; fast-&amp;gt;next != NULL){
        fast = fast-&amp;gt;next-&amp;gt;next;
        slow = slow-&amp;gt;next;
    }
    return slow;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;* 判断单链表是否存在环&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;题目描述&lt;/em&gt;: 输入一个单项链表，判断链表是否有环。  &lt;/p&gt;
&lt;p&gt;&lt;em&gt;分析&lt;/em&gt;: 通过两个指针 ，分别从链表的头节点出发，一个每次向后移动一步，另一个移动两步，两个指针移动速度不一样，如果存在环，那么两个指针一定会在环里相遇。  &lt;/p&gt;
&lt;p&gt;代码如下：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//判断链表是否有环  
bool hasCircle(Node *head, Node *&amp;amp;circleNode)
{
    Node *slow, *fast;
    slow = fast = head;
    while(fast != NULL &amp;amp;&amp;amp; fast-&amp;gt;next != NULL)
    {
        fast = fast-&amp;gt;next-&amp;gt;next;
        slow = slow-&amp;gt;next;
        if(fast == slow)
        {
            circleNode = fast;
            return ture;
        }
    }

    return false;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;* 找到环的入口点&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;题目描述&lt;/em&gt;: 输入一个单项链表，判断表是否有环。如果存在环，如何找到环的入口点？  &lt;/p&gt;
&lt;p&gt;&lt;em&gt;分析&lt;/em&gt;: 由上题可知，按照 p2 每次两步，p1 每次一步的方式走，发现 p2 和 p1 重合，确定了单向链表有环路了。接下来，让p2回到链表的头部，重新走，每次步长不是走2了，而是走1，那么当 p1 和 p2 再次相遇的时候，就是环路的入口了。  &lt;/p&gt;
&lt;p&gt;&lt;em&gt;为什么？&lt;/em&gt;：假定起点到环入口点的距离为 a，p1 和 p2 的相交点M与环入口点的距离为b，环路的周长为L，当 p1 和 p2 第一次相遇的时候，假定 p1 走了 n 步。那么有：  &lt;/p&gt;
&lt;p&gt;p1走的路径： &lt;code&gt;a+b ＝ n&lt;/code&gt;；&lt;br /&gt;
p2走的路径： &lt;code&gt;a+b+k&lt;em&gt;L = 2&lt;/em&gt;n&lt;/code&gt;； p2 比 p1 多走了k圈环路，总路程是p1的2倍  &lt;/p&gt;
&lt;p&gt;根据上述公式可以得到 &lt;code&gt;k*L=a+b=n&lt;/code&gt;显然，如果从相遇点M开始，p1 再走 n 步的话，还可以再回到相遇点，同时p2从头开始走的话，经过n步，也会达到相遇点M。  &lt;/p&gt;
&lt;p&gt;显然在这个步骤当中 p1 和 p2 只有前 a 步走的路径不同，所以当 p1 和 p2 再次重合的时候，必然是在链表的环路入口点上。 &lt;/p&gt;
&lt;p&gt;代码如下：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//找环的入口点  
Node* findLoopPort(Node *head)
{
    if(head == NULL || head-&amp;gt;next == NULL){
        return NULL;
    }

    Node *slow, *fast;
    slow = fast = head;

    while(fast != NULL &amp;amp;&amp;amp; fast-&amp;gt;next != NULL){
        fast = fast-&amp;gt;next-&amp;gt;next;
        slow = slow-&amp;gt;next;
        if(fast == slow){
            break;
        }
    }

    if(fast != slow) return NULL; //没有环

    fast = head;
    while(fast != slow){
        fast = fast-&amp;gt;next;
        slow = slow-&amp;gt;next;
    }

    return fast;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;* 判断两个链表是否相交&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;题目描述&lt;/em&gt;: 给出两个单向链表的头指针（如下如所示），&lt;br /&gt;
&lt;img alt="images1" src="/images/list/1.jpg" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;em&gt;解题思路&lt;/em&gt;:&lt;br /&gt;
1. 直接循环判断第一个链表的每个节点是否在第二个链表中。但，这种方法的时间复杂度为O(Length(h1) * Length(h2))。显然，我们得找到一种更为有效的方法，至少不能是O（N^2）的复杂度。  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;针对第一个链表直接构造hash表，然后查询hash表，判断第二个链表的每个节点是否在hash表出现，如果所有的第二个链表的节点都能在hash表中找到，即说明第二个链表与第一个链表有相同的节点。时间复杂度为为线性：O(Length(h1) + Length(h2))，同时为了存储第一个链表的所有节点，空间复杂度为O(Length(h1))。是否还有更好的方法呢，既能够以线性时间复杂度解决问题，又能减少存储空间？  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;转换为环的问题。把第二个链表接在第一个链表后面，如果得到的链表有环，则说明两个链表相交。如何判断有环的问题上面已经讨论过了，但这里有更简单的方法。因为如果有环，则第二个链表的表头一定也在环上，即第二个链表会构成一个循环链表，我们只需要遍历第二个链表，看是否会回到起始点就可以判断出来。这个方法的时间复杂度是线性的，空间是常熟。  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进一步考虑“如果两个没有环的链表相交于某一节点，那么在这个节点之后的所有节点都是两个链表共有的”这个特点，我们可以知道，如果它们相交，则最后一个节点一定是共有的。而我们很容易能得到链表的最后一个节点，所以这成了我们简化解法的一个主要突破口。那么，我们只要判断两个链表的尾指针是否相等。相等，则链表相交；否则，链表不相交。&lt;br /&gt;
所以，先遍历第一个链表，记住最后一个节点。然后遍历第二个链表，到最后一个节点时和第一个链表的最后一个节点做比较，如果相同，则相交，否则，不相交。这样我们就得到了一个时间复杂度，它为O((Length(h1) + Length(h2))，而且只用了一个额外的指针来存储最后一个节点。这个方法时间复杂度为线性O(N)，空间复杂度为O(1)，显然比解法三更胜一筹。  &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;解法四的代码如下：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//判断两个链表是否相交
bool isIntersect(Node *h1,Node *h2)
{
    if(h1 == NULL || h2 == NULL) return false;    //异常判断
    while(h1-&amp;gt;next != NULL)
    {
        h1 = h1-&amp;gt;next;
    }

    while(h2-&amp;gt;next != NULL)
    {
        h2 = h2-&amp;gt;next;
    }

    if(h1 == h2) return true;        //尾节点是否相同
    else return false;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;* 扩展：链表有环，如何判断相交&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;题目描述&lt;/em&gt;: 上面的问题都是针对链表无环的，那么如果现在，链表是有环的呢？上的方法还同样有效吗？  &lt;/p&gt;
&lt;p&gt;&lt;em&gt;分析&lt;/em&gt;: 如果有环且两个链表相交，则两个链表都有共同一个环，即环上任意一个节点都存在于两个链表上。因此，就可以判断链表上两指针相遇的那个节点，在不在另一条链表上。  &lt;/p&gt;
&lt;p&gt;代码如下：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//判断两个带环链表是否相交  
bool isIntersectWithLoop(Node *h1,Node *h2)
{
    Node *circleNode1,*circleNode2;
    if(!hasCircle(h1,circleNode1))    //判断链表带不带环，并保存环内节点
        return false;                //不带环，异常退出
    if(!hasCircle(h2,circleNode2))
        return false;

    Node *temp = circleNode2-&amp;gt;next;
    while(temp != circleNode2)
    {
        if(temp == circleNode1)
            return true;
        temp = temp-&amp;gt;next;
    }
    return false;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;* 扩展：连链表相交的第一个公共节点&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;题目描述&lt;/em&gt;: 如果两个五环单链表相交，怎么求出他们相交的第一个节点呢？  &lt;/p&gt;
&lt;p&gt;&lt;em&gt;分析&lt;/em&gt;: 采用对齐的思想。计算两个链表的长度 L1 , L2，分别用两个指针 p1 , p2 指向两个链表的头，然后将较长链表的 p1（假设为 p1）向后移动&lt;code&gt;L2 - L1&lt;/code&gt;个节点，然后再同时向后移动p1 , p2，直到 &lt;code&gt;p1 = p2&lt;/code&gt;。相遇的点就是相交的第一个节点。  &lt;/p&gt;
&lt;p&gt;代码如下：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//求两链表相交的第一个公共点
Node* findFirstInterNode(Node *l1, Node *l2)
{
    int len1 = listlength(l1);
    int len2 = listlength(l2);
    //两链表对齐
    if(len1 &amp;gt; len2){
        for(int i = 0; i&amp;lt;len1-len2; i++){
            l1 = l1-&amp;gt;next;
        }
    }
    else{
        for (int i = 0; i&amp;lt;len2-len1; i++){
            l2 = l2-&amp;gt;next;
        }
    }

    while(l1 != NULL){
        if(l1 == l2){
            return l1;
        }
        l1 = l1-&amp;gt;next;
        l2 = l2-&amp;gt;next;
    }

    return NULL;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;font size=4 color=OrangeRed&gt;总结：可以发现，在链表的问题中，通过两个指针来提高效率是很值得考虑的一个解决方案，所以一定要记住这种结题思路。记住集中典型的链表问题解决方案，很多类似的题目都可以转换到熟悉的问题再结局。&lt;/font&gt;  &lt;/p&gt;</summary><category term="面试"></category><category term="笔试"></category></entry><entry><title>32位和64位下内置类型的字节数</title><link href="http://blog.zzfanhero.info/articles/32wei-he-64wei-xia-nei-zhi-lei-xing-de-zi-jie-shu.html" rel="alternate"></link><updated>2016-03-26T00:00:00+08:00</updated><author><name>zzfan</name></author><id>tag:blog.zzfanhero.info,2016-03-26:articles/32wei-he-64wei-xia-nei-zhi-lei-xing-de-zi-jie-shu.html</id><summary type="html">&lt;p&gt;&lt;font size=4 color=Green&gt;摘要：感觉很熟悉，但是有时候有点不确定，还是记一下吧，免得以后测试起来麻烦。&lt;/font&gt;  &lt;/p&gt;
&lt;h3&gt;* 具体如下&lt;/h3&gt;
&lt;h4&gt;+ 32位机器下&lt;/h4&gt;
&lt;p&gt;char: 1&lt;br /&gt;
int:  4&lt;br /&gt;
unsigned int: 4&lt;br /&gt;
long: 4&lt;br /&gt;
long long: 8 &lt;br /&gt;
float: 4&lt;br /&gt;
double: 8&lt;br /&gt;
指针： 4&lt;br /&gt;
short int: 2&lt;br /&gt;
unsigned long: 4  &lt;/p&gt;
&lt;h4&gt;+ 64位机器下&lt;/h4&gt;
&lt;p&gt;char: 1&lt;br /&gt;
int: 大多数是4&lt;br /&gt;
unsigned int: 4&lt;br /&gt;
long: 8&lt;br /&gt;
long long: 8&lt;br /&gt;
float: 4&lt;br /&gt;
double: 8&lt;br /&gt;
指针： 8&lt;br /&gt;
long double: 16&lt;br /&gt;
short int: 4&lt;br /&gt;
unsigned long: 8  &lt;/p&gt;</summary><category term="笔试"></category><category term="面试"></category></entry><entry><title>C++ STL--stack/queue的使用方法</title><link href="http://blog.zzfanhero.info/articles/c-stl-stackqueuede-shi-yong-fang-fa.html" rel="alternate"></link><updated>2016-03-25T00:00:00+08:00</updated><author><name>zzfan</name></author><id>tag:blog.zzfanhero.info,2016-03-25:articles/c-stl-stackqueuede-shi-yong-fang-fa.html</id><summary type="html">&lt;p&gt;&lt;font size=4 color=Green&gt;摘要：之前队这两个容器不是很熟悉，有时候用起来还不是很确定，有点时间就总结下。&lt;/font&gt;&lt;/p&gt;
&lt;h3&gt;1. stack&lt;/h3&gt;
&lt;p&gt;stack 模板类的定义在&lt;stack&gt;头文件中。&lt;br /&gt;
stack 模板类需要两个模板参数，一个是元素类型，一个容器类型，但只有元素类型是必要&lt;br /&gt;
的，在不指定容器类型时，默认的容器类型为deque。&lt;br /&gt;
定义stack 对象的示例代码如下：&lt;br /&gt;
stack&lt;int&gt; s1;&lt;br /&gt;
stack&lt;string&gt; s2;&lt;br /&gt;
stack 的基本操作有：&lt;br /&gt;
入栈，如例：s.push(x);&lt;br /&gt;
出栈，如例：s.pop();注意，出栈操作只是删除栈顶元素，并不返回该元素。&lt;br /&gt;
访问栈顶，如例：s.top()&lt;br /&gt;
判断栈空，如例：s.empty()，当栈空时，返回true。&lt;br /&gt;
访问栈中的元素个数，如例：s.size()。  &lt;/p&gt;
&lt;h3&gt;2. queue&lt;/h3&gt;
&lt;p&gt;queue 模板类的定义在&lt;queue&gt;头文件中。&lt;br /&gt;
与stack 模板类很相似，queue 模板类也需要两个模板参数，一个是元素类型，一个容器类&lt;br /&gt;
型，元素类型是必要的，容器类型是可选的，默认为deque 类型。&lt;br /&gt;
定义queue 对象的示例代码如下：&lt;br /&gt;
queue&lt;int&gt; q1;&lt;br /&gt;
queue&lt;double&gt; q2;  &lt;/p&gt;
&lt;p&gt;queue 的基本操作有：&lt;br /&gt;
入队，如例：q.push(x); 将x 接到队列的末端。&lt;br /&gt;
出队，如例：q.pop(); 弹出队列的第一个元素，注意，并不会返回被弹出元素的值。&lt;br /&gt;
访问队首元素，如例：q.front()，即最早被压入队列的元素。&lt;br /&gt;
访问队尾元素，如例：q.back()，即最后被压入队列的元素。&lt;br /&gt;
判断队列空，如例：q.empty()，当队列空时，返回true。&lt;br /&gt;
访问队列中的元素个数，如例：q.size()  &lt;/p&gt;</summary><category term="code"></category><category term="笔试"></category></entry><entry><title>网易面试总结--数组中元素奇偶出现问题</title><link href="http://blog.zzfanhero.info/articles/wang-yi-mian-shi-zong-jie-shu-zu-zhong-yuan-su-qi-ou-chu-xian-wen-ti.html" rel="alternate"></link><updated>2016-03-25T00:00:00+08:00</updated><author><name>zzfan</name></author><id>tag:blog.zzfanhero.info,2016-03-25:articles/wang-yi-mian-shi-zong-jie-shu-zu-zhong-yuan-su-qi-ou-chu-xian-wen-ti.html</id><summary type="html">&lt;p&gt;&lt;font color=Green&gt;摘要：今天室友参加了网易的电话面试，觉得里面的题很有意思，总共三道题，我之前只遇到过第二题，第一和第二题还是可以的。本来想把三题放在一起，结果发现拓展的有点多还是分开。&lt;/font&gt;  &lt;/p&gt;
&lt;h3&gt;* 数组中有一个元素出现了奇数次，其他元素出现了偶数次，找出这个元素&lt;/h3&gt;
&lt;p&gt;最简单的方法，用异或&lt;code&gt;^&lt;/code&gt;，异或数组中所有的数，最后等于的数是出现为奇数的数，复杂度为O(n).  &lt;/p&gt;
&lt;p&gt;&lt;font size=4 color=Red&gt;注意：如果要找出数组中两个元素出现了奇数次呢，其他元素出现了偶数次。&lt;/font&gt;&lt;br /&gt;
把原数组分为两个子数组。在每个子数组中，包含一个只出现一次的数字，而其他数字都出现两次。如果能够这样拆分原数组，按照前面的办法就是分别求出这两个只出现一次的数字了。  &lt;/p&gt;
&lt;p&gt;我们还是从头到尾依次异或数组中的每一个数字，那么最终得到的结果就是两个只出现一次的数字的异或结果。因为其他数字都出现了两次，在异或中全部抵消掉了。由于这两个数字肯定不一样，那么这个异或结果肯定不为0，也就是说在这个结果数字的二进制表示中至少就有一位为1。我们在结果数字中找到第一个为1的位的位置，记为第N位。现在我们以第N位是不是1为标准把原数组中的数字分成两个子数组，第一个子数组中每个数字的第N位都为1，而第二个子数组的每个数字的第N位都为0。  &lt;/p&gt;
&lt;p&gt;现在我们已经把原数组分成了两个子数组，每个子数组都包含一个只出现一次的数字，而其他数字都出现了两次。因此到此为止，所有的问题我们都已经解决。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/*************************************************************************&lt;/span&gt;
&lt;span class="cm"&gt;    &amp;gt; File Name: test3.cpp&lt;/span&gt;
&lt;span class="cm"&gt;    &amp;gt; Author: zzfan&lt;/span&gt;
&lt;span class="cm"&gt;    &amp;gt; Mail: zzfan@mail.ustc.edu.cn &lt;/span&gt;
&lt;span class="cm"&gt;    &amp;gt; Created Time: Thu 24 Mar 2016 07:23:31 PM PDT&lt;/span&gt;
&lt;span class="cm"&gt; ************************************************************************/&lt;/span&gt;

&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="nf"&gt;IsBit1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;indexBit&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;num&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;indexBit&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;FindFirstBitIs1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;indexBit&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(((&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;indexBit&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;num&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="n"&gt;indexBit&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;indexBit&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;FindNumsAppearOnce&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[],&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;num1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;num2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;resultOR&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;resultOR&lt;/span&gt; &lt;span class="o"&gt;^=&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;indexOf1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FindFirstBitIs1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;resultOR&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;num1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;num2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IsBit1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;indexOf1&lt;/span&gt;&lt;span class="p"&gt;)){&lt;/span&gt;
            &lt;span class="n"&gt;num1&lt;/span&gt; &lt;span class="o"&gt;^=&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;num2&lt;/span&gt; &lt;span class="o"&gt;^=&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;FindNumsAppearOnce&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]),&lt;/span&gt;&lt;span class="n"&gt;n1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;n2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;n1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39; &amp;#39;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;n2&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary><category term="面试"></category><category term="算法"></category><category term="笔试"></category></entry><entry><title>二叉树的遍历及应用</title><link href="http://blog.zzfanhero.info/articles/er-cha-shu-de-bian-li-ji-ying-yong.html" rel="alternate"></link><updated>2016-03-24T00:00:00+08:00</updated><author><name>zzfan</name></author><id>tag:blog.zzfanhero.info,2016-03-24:articles/er-cha-shu-de-bian-li-ji-ying-yong.html</id><summary type="html">&lt;p&gt;&lt;font color=Green&gt;摘要：先中后序遍历，深度广度，层次，路径，每层节点数。 &lt;/font&gt;&lt;/p&gt;
&lt;h3&gt;* 二叉树的遍历&lt;/h3&gt;
&lt;p&gt;由于二叉树是一种递归结构，所以我们很容易用递归方式实现其遍历操作。  &lt;/p&gt;
&lt;h4&gt;1. 先序遍历&lt;/h4&gt;
&lt;p&gt;（1）访问根节点；  （2）先序遍历左子树；  （3）先序遍历右子树；  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;void PreOrder(Bitree T){
    if(!T) return;
    else{
        visite(T-&amp;gt;data);
        PreOrder(T-&amp;gt;lchild);
        PreOrder(T-&amp;gt;rchild);
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;2. 中序遍历&lt;/h4&gt;
&lt;p&gt;（1）先序遍历左子树； （1）访问根节点； （3）先序遍历右子树；  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; void InOrder(Bitree T){
     if(!T) return;
     else{
        InOrder(T-&amp;gt;lchild);
         visite(T-&amp;gt;data);
         InOrder(T-&amp;gt;rchild);
     }
 }
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;3. 后序遍历&lt;/h4&gt;
&lt;p&gt;（1）先序遍历左子树； （2）先序遍历右子树； （3）访问根节点；  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;void PostOrder(Bitree T){
    if(!T) return;
    else{
        PostOrder(T-&amp;gt;lchild);
        PostOrder(T-&amp;gt;rchild);
        visite(T-&amp;gt;data);
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;4. 层序遍历二叉树&lt;/h4&gt;
&lt;p&gt;（1）初始化一个空队列；&lt;br /&gt;
（2）非空根指针入队。&lt;br /&gt;
     --队头元素出对，访问之；
     --若被访节点有左孩子，则左孩子入队；
     --若被访节点有右孩子，则右孩子入队；&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;void LayerTraversal(Bitree T){
    InitQueue(Q);
    if(T) EnQueue(Q, T));
    while(!QueueEmpty(Q)){
        DeQueue(Q, p);
        visite(p-&amp;gt;data);
        if(p-&amp;gt;lchild) EnQueue(Q, p-&amp;gt;lchild);
        if(p-&amp;gt;rhicld) EnQueue(Q, p-&amp;gt;rchild);
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;font color=Blue&gt;显然，对二叉树的各种算法中，基本操作是访问节点。不论按哪种次序遍历含有n个节点的二叉树，其时间复杂度均为O(n).&lt;/font&gt;  &lt;/p&gt;
&lt;h3&gt;* 其他运算&lt;/h3&gt;
&lt;p&gt;&lt;font color=Red&gt;记住：递归是二叉树的固有特性，采用递归的方式来实现二叉树的有很多操作或运算就非常自然而且简单。&lt;/font&gt;  &lt;/p&gt;
&lt;h4&gt;1. 求二叉树的节点个数&lt;/h4&gt;
&lt;p&gt;&lt;font color=Blue&gt;其实利用任何一种遍历方式都可以，下面我们先介绍两种方案。&lt;/font&gt;&lt;br /&gt;
（1）利用二叉树的递归特性。若二叉树为空，则节点数为0；否则&lt;br /&gt;
　　二叉树节点个数　＝　左子树节点个数　＋　右子树节点个数　＋　１个根节点&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int CountNodes1(Bitree T){
    if(!T) return 0;
    else{
        n1 = CountNodes1(T-&amp;gt;lchild);
        n2 = CountNodes2(T-&amp;gt;rchild);
        return(1 + n1 + n2);
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;（２）利用先序遍历计数  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;void CountNode2(Bitree T){
    if(!T) return 0;
    else{
        n++;
        CountNodes2(T-&amp;gt;lchild, n);
        CountNodes2(T-&amp;gt;rchild, n);
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;2. 输出二叉树每个节点的层次数&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;void Level(Bitree T){
    if(!T) return;
    else{
        lev++;
        printf(T-&amp;gt;data,lev);
        Level(T-&amp;gt;lchild, lev);
        Level(T-&amp;gt;rchild, lev);
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;3. 求二叉树深度和宽度&lt;/h4&gt;
&lt;p&gt;（1）二叉树深度&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;int&lt;/span&gt; &lt;span class="nt"&gt;Depth&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;Bitree&lt;/span&gt; &lt;span class="nt"&gt;T&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;return&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;else&lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;hl&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Depth&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;lchild&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;hr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Depth&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rchild&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;return&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hl&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;hr&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="n"&gt;hl&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;hr&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;（1）二叉树宽度  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//求二叉树的宽度  
int GetWidth(tagBiNode *pRoot)  
{  
    if (pRoot == NULL)  
    {  
        return 0;  
    }  

    int nLastLevelWidth = 0;//记录上一层的宽度  
    int nTempLastLevelWidth = 0;  
    int nCurLevelWidth = 0;//记录当前层的宽度  
    int nWidth = 1;//二叉树的宽度  
    queue&amp;lt;BiNode *&amp;gt; myQueue;  
    myQueue.push(pRoot);//将根节点入队列  
    nLastLevelWidth = 1;      
    tagBiNode *pCur = NULL;  

    while (!myQueue.empty())//队列不空  
    {  
        nTempLastLevelWidth = nLastLevelWidth;  
        while (nTempLastLevelWidth != 0)  
        {  
            pCur = myQueue.front();//取出队列头元素  
            myQueue.pop();//将队列头元素出对  

            if (pCur-&amp;gt;left != NULL)  
            {  
                myQueue.push(pCur-&amp;gt;left);  
            }  

            if (pCur-&amp;gt;right != NULL)  
            {  
                myQueue.push(pCur-&amp;gt;right);  
            }  

            nTempLastLevelWidth--;  
        }  

        nCurLevelWidth = myQueue.size();  
        nWidth = nCurLevelWidth &amp;gt; nWidth ? nCurLevelWidth : nWidth;  
        nLastLevelWidth = nCurLevelWidth;  
    }  

    return nWidth;  
}  
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;4. 输出二叉树根节点到所有叶子节点的路径&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;void OutPath(Bitree T, Stack &amp;amp;S){
    if(T){
        Push(S,T);
        if(!T-&amp;gt;lchild &amp;amp;&amp;amp; !T-&amp;gt;rchild){
            StackTraverse(S);
        }
        OutPath(T-&amp;gt;lchild,S);
        OutPaht(T-&amp;gt;rchild,S);
        Pop(S,e);
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;font size=4 color=Red&gt;总结：二叉树的操作大多是递归，层次遍历的用了一个队列，所以说还是比较简单的，求宽度的时候就是层次遍历的一个拓展&lt;/font&gt;  &lt;/p&gt;</summary><category term="数据结构"></category><category term="面试"></category></entry><entry><title>进程的创建和销毁</title><link href="http://blog.zzfanhero.info/articles/jin-cheng-de-chuang-jian-he-xiao-hui.html" rel="alternate"></link><updated>2016-03-24T00:00:00+08:00</updated><author><name>zzfan</name></author><id>tag:blog.zzfanhero.info,2016-03-24:articles/jin-cheng-de-chuang-jian-he-xiao-hui.html</id><summary type="html">&lt;p&gt;&lt;font color=Green&gt;刚在群里面看到有人问到这个问题，觉得自己用Libevent创建线程很熟悉，但是对于进程没有什么概念就总结下。 &lt;/font&gt;&lt;/p&gt;
&lt;h3&gt;* 进程的创建fork()函数&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;sys/types.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="n"&gt;pit_t&lt;/span&gt; &lt;span class="nf"&gt;fork&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;由fork创建的新进程被称为子进程(child process)。该函数被调用一次，但返回两次。两次返回的区别是子进程的返回值是0，而父进程的返回值则是 新子进程的进程ID。将子进程ID返回给父进程的理由是:因为一个进程的子进程可以多于一个，所有没有一个函数使一个进程可以获得其所有子进程的进程ID。fork使子进程得到返回值0的理由是:一个进程只会有一个父进程，所以子进程总是可以调用getppid以获得其父进程的进程ID(进程 ID  0总是由交换进程使用，所以一个子进程的进程ID不可能为0)。&lt;br /&gt;
    子进程和父进程继续执行fork之后的指令。子进程是父进程的复制品。例如，子进程获得父进程数据空间、堆和栈的复制品。注意，这是子进程拥有的拷贝。父、子进程并共享这些存储部分。如果正文段是只读的，则父、子进程共享正文段。&lt;br /&gt;
    现在很多的实现并不做一个父进程数据段和堆的完全拷贝，因为在fork之后经常跟随着exec。作为替代，使用了写时复制(copy-on-write,cow)的技术。这些区域由父、子进程共享，而且内核将他们的存取许可权改变位只读的。如果有进程试图修改这些区域，则内核包异常，典型的是虚存系统中的“页”，做一个拷贝。  &lt;/p&gt;
&lt;p&gt;实例1：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int glob = 6;
char buf[] = &amp;quot;a write to stdout\n&amp;quot;;

int main()
{
    int var;
    int pid;

    var = 88;

    if(write(STDOUT_FILENO,buf,sizeof(buf) -1) != sizeof(buf) -1)
    {
        perror(&amp;quot;fail to write&amp;quot;);
        return -1;
    }

    printf(&amp;quot;before fork\n&amp;quot;);

    if((pid = fork()) &amp;lt; 0)
    {
        perror(&amp;quot;fail to fork&amp;quot;);
        return -1;
    }else 
        if(pid == 0)
        {
            glob ++;
            var ++;
        }else{
            sleep(2);
        }

    printf(&amp;quot;pid = %d,glob = %d,var = %d\n&amp;quot;,getpid(),glob,var);
    exit(0);
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;运行结果：
&lt;img alt="jieguo1" src="/images/progress/1.png" /&gt;  &lt;/p&gt;
&lt;p&gt;从上面可以看出，因为子进程和父进程拥有独立的物理内存空间，所以当子进程对拷贝来的数据做修改的时候，并没有影响到父进程。  &lt;/p&gt;
&lt;p&gt;&lt;em&gt;注意:&lt;/em&gt;&lt;br /&gt;
1. 一般来说，fork之后父进程先执行还是子进程先执行是不确定的。这取决于内核所使用的调度算法。&lt;br /&gt;
2. 从上面可以看到两次的运行结果不一样。我们知道write函数是不带缓存的。因为在fork之前调用write，所以其数据写到标准输出一次。但是，标准 I/O库是带缓存的。如果标准输出连到终端设备，则它是行缓存的，否则它是全缓存的。当以交互方式运行该程序时，只得到printf输出的行一次，其原因是标准输出缓存由新行符刷新。但是当将标准输出重新定向到一个文件时，却得到printf输出行两次。其原因是，在fork之前调用了printf一次，当调用fork时，该行数据仍在缓存中，然后在父进程数据空间复制到子进程中时，该缓存数据也被复制到子进程中。于是那时父、子进程各自有了带该行内容的缓存。在exit之前的第二个printf将其数据添加到现存的缓存中。当每个进程终止时，其缓存中的内容被写到相应文件中。  &lt;/p&gt;
&lt;h3&gt;* copy-on-write工作原理&lt;/h3&gt;
&lt;p&gt;假设进程A创建子进程B,之后进程A和进程B共享A的地址空间，同时该地址空间中的页面全部被标识为写保护。此时B若写address的页面，由于写保护的原因会引起写异常，在异常处理中，内核将address所在的那个写保护页面复制为新的页面，让B的address页表项指向该新的页面，新页面可写。而A的address页表项依然指向那个写保护的页面。然后当B在访问address时就会直接访问新的页面了，不会在访问到哪个写保护的页面。当A试图写address所在的页面时，由于写保护的原因此时也会引起异常，在异常处理中，内核如果发现该页面只有一个拥有进程，此种情况下也就是A,则直接对该页面取消写保护，此后当A再访问address时不会在有写保护错误了。如果此时A又创建子进程C,则该address所在的页面又被设置为写保护，拥有进程A和C,同时其他页面例如PAGEX依然维持写保护，只是拥有进程A、B和C。如果此时A访问PAGEX，则异常处理会创建一个新页面并将PAGEX中的内容复制到该页面，同时A相应 的pte指向该新页面。如果此时C也访问PAGEX，也会复制新页面并且让C对应的pte指向新页面。如果B再访问PAGEX，则由于此时PAGEX只有一个拥有进程B，故不再复制新页面，而是直接取消该页面的写保护，由于B的pte本来就是直接指向该页面，所以无需要在做其它工作。  &lt;/p&gt;
&lt;h3&gt;* exit和_exit&lt;/h3&gt;
&lt;p&gt;(1)正常终止:&lt;br /&gt;
    (a)在main函数内执行return语句。这等效于调用exit。&lt;br /&gt;
    (b)调用exit函数&lt;br /&gt;
    (c)调用_exit系统调用函数  &lt;/p&gt;
&lt;p&gt;(2)异常终止:&lt;br /&gt;
    (a)调用abort。它产生SIGABRT信号，所以是一种异常终止的一种特列。&lt;br /&gt;
    (b)当进程接收到某个信号时。例如，进程越出其地址空间访问存储单元，或者除以0,内核就会为该进程产生相应的信号。  &lt;/p&gt;
&lt;p&gt;注意:不管进程如何终止，最后都会执行内核中的同一段代码。这段代码为相应进程关闭所有打开描述符，释放它所使用的存储器等。  &lt;/p&gt;
&lt;p&gt;exit和_exit的不同：&lt;br /&gt;
&lt;img alt="images3" src="/images/progress/3.png" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;font color=OrangeRed&gt; exit()函数与_exit()函数最大的区别就在于exit()函数在调用exit系统调用之前要检查文件的打开情况，把文件缓冲区中的内容写回文件，就是"清理I/O"缓冲。&lt;/font&gt;  &lt;/p&gt;
&lt;h3&gt;* 进程的创建函数vfork()函数&lt;/h3&gt;
&lt;p&gt;vfork与fork一样都创建一个子进程，但是它并不将父进程的地址空完全复制到子进程中，因为子进程会立即调用exec(或exit)于是也就不会存、访该地址空间。不过在子进程调用exec或exit之前，它在父进程的空间中运行。  &lt;/p&gt;
&lt;p&gt;vfork和fork之间的另一个区别是:vfork保证子进程先运行，在它调用exec或exit之后 父进程才可能被调度运行。(如果在调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁)  &lt;/p&gt;
&lt;p&gt;&lt;img alt="images4" src="/images/progress/4.png" /&gt;  &lt;/p&gt;
&lt;p&gt;编译运行：  &lt;/p&gt;
&lt;p&gt;&lt;img alt="images5" src="/images/progress/5.png" /&gt;  &lt;/p&gt;
&lt;p&gt;因为我们知道vfork保证子进程先运行，子进程运行结束后，父进程才开始运行。所以，第一次打印的是子进程的打印的信息，可以看到var值变成了89。子进程结束后，父进程运行，父进程首先打印fork调用返回给他pid的值（就是子进程pid）。以上我们可以看出，vfork创建的子进程和父进程运行的地址空间相同(子进程改变了var 值，父进程中的var值也进行了改变)。  &lt;/p&gt;
&lt;p&gt;注意:如果子进程中执行的是exec函数，那就是典型的fork的copy-on-wirte  &lt;/p&gt;
&lt;h3&gt;* 进程的监控&lt;/h3&gt;
&lt;p&gt;这一部分讲的是父进程对子进程的监控操作。主要涉及到三个知识点：监控子进程的必要性（即其目的）；系统调用wait()及其相关调用；SIGCHLD信号的处理。后两个知识点是父进程对子进程的监控手段。  &lt;/p&gt;
&lt;h4&gt;一. 监控的必要性&lt;/h4&gt;
&lt;p&gt;很多时候父进程都需要监控子进程的状态，有以下几点值得声明：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;父子进程之间的同步，以及检查子进程是否正常结束。比如父进程的某些操作需要等子进程结束才能执行，有时候父进程还需要获取子进程的退出状态等信息，这就需要对子进程进行监控。  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;避免僵尸进程大量产生。子进程结束后，内核会在父进程调用wait()或者waitpid()之类的函数之前，将结束的子进程转为僵尸进程（关于僵尸进程及其危害可自行查阅资料）。父进程调用wait()或者waitpid()之类的函数之后，内核会完全清除已经结束的子进程，否则在父进程结束之后就会残留下大量的僵尸进程。  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;避免孤儿进程出现，虽然不像僵尸进程那样对系统会带来较大影响，依然不建议父进程不管子进程状态擅自先结束执行。  &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;font color=OrangeRed&gt;僵尸进程以及孤儿进程&lt;/font&gt;  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;#include
#include

int main()
{
    int pid;

    if((pid = fork()) &amp;lt; 0)
    {
        perror(&amp;quot;Fail  to fork&amp;quot;);
        return -1;
    }else if(pid == 0){
        printf(&amp;quot;child exit now.\n&amp;quot;);
        exit(0);
    }else{
        while(1);
    }

    exit(0);
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;运行结果：&lt;br /&gt;
&lt;img alt="images6" src="/images/progress/6.png" /&gt;  &lt;/p&gt;
&lt;p&gt;---从以上可以看出，子进程正常退出时，处于僵尸态。这个时候子进程的pid,以及内核栈资源并没有释放，这样是不合理的，我们应该避免僵尸进程。如果父进程先退出呢，子进程又会怎样？  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int main()
{
    int pid;

    if((pid = fork()) &amp;lt; 0)
    {
        perror(&amp;quot;Fail  to fork&amp;quot;);
        return -1;
    }else if(pid == 0){
        printf(&amp;quot;child runing now - pid : %d.\n&amp;quot;,getpid());
        getchar();
        printf(&amp;quot;child exiting now - pid : %d.\n&amp;quot;,getpid());
        exit(0);
    }else{
        printf(&amp;quot;Father wait zombie now - pid : %d.\n&amp;quot;,getpid());
        wait(NULL);
        printf(&amp;quot;Father exiting now - pid : %d.\n&amp;quot;,getpid());
        exit(0);
    }

}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;运行结果：&lt;br /&gt;
&lt;img alt="images7" src="/images/progress/7.png" /&gt;  &lt;/p&gt;
&lt;p&gt;---从上面可以看出，如果父进程先退出，则子进程的父进程的ID号变为1，也就是说当一个子进程的父进程退出时，这个子进程会被init进程自动收养。  &lt;/p&gt;
&lt;h4&gt;二. wait()及其相关调用&lt;/h4&gt;
&lt;p&gt;这一部分只谈 wait() 和 waitpid() 这两个系统调用，他们都可以用于监控子进程的状态。他们的定义如下：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;   &lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;sys/types.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
   &lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;sys/wait.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
   &lt;span class="kt"&gt;pid_t&lt;/span&gt; &lt;span class="nf"&gt;wait&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;status&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
   &lt;span class="kt"&gt;pid_t&lt;/span&gt; &lt;span class="nf"&gt;waitpid&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;pid_t&lt;/span&gt; &lt;span class="n"&gt;pid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;status&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;options&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="err"&gt;对于这两个调用的关系做以下几点说明：&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;二者都有一个status参数用于返回子进程终止状态。  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;二者都有一个pid_t类型的返回值，表示监控到的子进程的PID。  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;出错时都返回-1，如果errno被设置为ECHILD则表示没有子进程可以等待，也就是说父进程的所有子进程都已结束并被父进程获取过结束状态。  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;wait() 只能按顺序等待结束的子进程（例如，调用wait之前已有多个子进程结束，则wait一次只会返回一个子进程的终止状态，顺序和子进程的结束顺序一致。），而waitpid则可以通过参数pid选择等待方式（pid大于0 等待指定的子进程；pid=0 等待与调用进程同一进程组的所有子进程；pid=-1等待所有子进程；pid小于-1等待进程组标示符与pid绝对值相等的所有子进程）。  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;wait() 属于阻塞式等待，直到有子进程结束才返回，而waitpid() 可以通过参数options来指定等待方式（WUNTRACED：返回已经终止的子进程和因信号而停止的子进程信息；WCONTINUED：返回因SIGCONT信号恢复执行的已停止的子进程的状态信息；WNOHANG：如果指定等待的子进程的状态未发生改变则立即返回，不会阻塞）。  &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;不管是wait() 还是waitpid() ，他们返回的status都可以通过头文件&lt;code&gt;&lt;sys/wait.h&gt;&lt;/code&gt;中定义的一组标准宏来解析（这些宏的名字还是很好记的：WIFEXITED(status)；正常结束；WIFSIGNALED(status)：被信号杀死的；WIFSTOPPED(status)：被信号停止的；WIFCONTINUED(status)：被信号停止后有被信号SIGCONT恢复执行的）。每一个返回的status解析后只会有一个宏返回真值。   &lt;/p&gt;</summary><category term="面试"></category></entry><entry><title>一些我不知道的Linux命令</title><link href="http://blog.zzfanhero.info/articles/yi-xie-wo-bu-zhi-dao-de-linuxming-ling.html" rel="alternate"></link><updated>2016-03-24T00:00:00+08:00</updated><author><name>zzfan</name></author><id>tag:blog.zzfanhero.info,2016-03-24:articles/yi-xie-wo-bu-zhi-dao-de-linuxming-ling.html</id><summary type="html">&lt;p&gt;&lt;font color=Green&gt;摘要：刚看到ps命令，觉得之前一直没怎么搞明白，以前碰到的Linux命令也没有总结，刚在写blog就写一篇，以后的都总结在这吧。&lt;/font&gt;  &lt;/p&gt;
&lt;h3&gt;1. ps -ef 和 ps aux&lt;/h3&gt;
&lt;p&gt;ps aux 是用BSD的格式来显示 java这个进程&lt;br /&gt;
显示的项目有：USER , PID , %CPU , %MEM , VSZ , RSS , TTY , STAT , START , TIME , COMMAND&lt;br /&gt;
ps -ef 是用标准的格式显示java这个进程&lt;br /&gt;
显示的项目有：UID , PID , PPID , C , STIME , TTY , TIME , CMD  &lt;/p&gt;
&lt;p&gt;&lt;font color=Orange&gt;注意：ps -ef比 ps aux好的一点就是可以查看父进程号&lt;/font&gt;  &lt;/p&gt;</summary><category term="面试"></category><category term="笔试"></category></entry><entry><title>[LeetCode]Shortest World Distance</title><link href="http://blog.zzfanhero.info/articles/leetcodeshortest-world-distance.html" rel="alternate"></link><updated>2016-03-23T00:00:00+08:00</updated><author><name>zzfan</name></author><id>tag:blog.zzfanhero.info,2016-03-23:articles/leetcodeshortest-world-distance.html</id><summary type="html"></summary><category term="LeetCode"></category><category term="笔试"></category></entry><entry><title>哈夫曼树和哈夫曼编码</title><link href="http://blog.zzfanhero.info/articles/ha-fu-man-shu-he-ha-fu-man-bian-ma.html" rel="alternate"></link><updated>2016-03-22T00:00:00+08:00</updated><author><name>zzfan</name></author><id>tag:blog.zzfanhero.info,2016-03-22:articles/ha-fu-man-shu-he-ha-fu-man-bian-ma.html</id><summary type="html">&lt;p&gt;&lt;font color=Green&gt;摘要：哈夫曼树（Huffman），又称为最有二叉树，在通信/数据压缩/决策和算法设计等方面有着广泛的应用。之前看到一个比较有意思的题目，刚好用到哈夫曼树，觉得哈夫曼算法真的很有用。 &lt;/font&gt;&lt;/p&gt;
&lt;h3&gt;* 哈夫曼树&lt;/h3&gt;
&lt;p&gt;+概念：
路径和路径的长度,树的路径长度（树根到每个节点的路径长度之和），节点的权值（除节点数据的元素值之外，在赋予节点的一个有意义的数值），节点的带权路径长度（树根节点到某个节点的路径长度与该节点权值的乘积）。    &lt;/p&gt;
&lt;p&gt;&lt;font color=OrangeRed&gt;树的带权路径长度：树中所有叶子节点的带权路径产度之和，通常记作：&lt;br /&gt;
&lt;img alt="wpl" src="/images/huffman/1.png" /&gt;&lt;/font&gt;  &lt;/p&gt;
&lt;p&gt;+哈夫曼树的构造：&lt;br /&gt;
&lt;img alt="create" src="/images/huffman/2.png" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;font color=OrangeRed&gt;关于哈夫曼树的注意点：&lt;/font&gt;&lt;br /&gt;
&lt;img alt="idea" src="/images/huffman/3.png" /&gt;  &lt;/p&gt;
&lt;h3&gt;* 哈夫曼编码&lt;/h3&gt;
&lt;p&gt;+概念：&lt;br /&gt;
&lt;img alt="yima" src="/images/huffman/4.png" /&gt;&lt;/p&gt;
&lt;p&gt;+编码：&lt;br /&gt;
&lt;img alt="yima" src="/images/huffman/5.png" /&gt;&lt;/p&gt;
&lt;p&gt;+译码：&lt;br /&gt;
&lt;img alt="yima" src="/images/huffman/6.png" /&gt;&lt;/p&gt;</summary><category term="面试"></category></entry><entry><title>笔试题－格雷码和微信红包</title><link href="http://blog.zzfanhero.info/articles/bi-shi-ti-ge-lei-ma-he-wei-xin-hong-bao.html" rel="alternate"></link><updated>2016-03-20T00:00:00+08:00</updated><author><name>zzfan</name></author><id>tag:blog.zzfanhero.info,2016-03-20:articles/bi-shi-ti-ge-lei-ma-he-wei-xin-hong-bao.html</id><summary type="html">&lt;p&gt;&lt;font color=Green&gt;腾讯的两道笔试题，挺灵活的，觉得很有必要分析下，就写下来．另外我还分析了一下字符串的输入等．&lt;/font&gt;&lt;/p&gt;
&lt;h3&gt;* 关于字符串题目的输入的一些需要注意的地方&lt;/h3&gt;
&lt;p&gt;+论&lt;code&gt;cin.get()&lt;/code&gt;的重要行,看如下代码，第一行输入数组的个数，第二行输入数组．  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;sstream&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;tab&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cin&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="nf"&gt;size&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
                &lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;lay&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;cin&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;get&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
                &lt;span class="n"&gt;getline&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cin&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                &lt;span class="n"&gt;stringstream&lt;/span&gt; &lt;span class="n"&gt;sp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nf"&gt;size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
                    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                    &lt;span class="n"&gt;sp&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                    &lt;span class="n"&gt;lay&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;lay&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;size&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
                    &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;lay&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

        &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;font color=OrangeRed&gt;如果没有cin.get(),那么换行符没有被读掉，也就是说geline()将读不到下一行&lt;/font&gt;  &lt;/p&gt;
&lt;h3&gt;* Gifts问题&lt;/h3&gt;
&lt;p&gt;&lt;img alt="gifts" src="/images/gifts.png" /&gt;  &lt;/p&gt;
&lt;p&gt;+需要注意的是题目中超过一半这个提示～～，很关键，是编程之美中的寻找水王的一道变样题．  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/*************************************************************************&lt;/span&gt;
&lt;span class="cm"&gt;    &amp;gt; File Name: gifts.cpp&lt;/span&gt;
&lt;span class="cm"&gt;    &amp;gt; Author: zzfan&lt;/span&gt;
&lt;span class="cm"&gt;    &amp;gt; Mail: zzfan@mail.ustc.edu.cn &lt;/span&gt;
&lt;span class="cm"&gt;    &amp;gt; Created Time: 2016年03月20日 星期日 19时57分01秒&lt;/span&gt;
&lt;span class="cm"&gt; ************************************************************************/&lt;/span&gt;

&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;sstream&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;getValue&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;gifts&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;gifts&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gifts&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
            &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;gifts&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
            &lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; 
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gifts&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; 
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;gifts&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;itemp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;cin&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;cin&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;itemp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;gifts&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;itemp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;getValue&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gifts&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;* 生成格雷码&lt;/h3&gt;
&lt;p&gt;&lt;img alt="graycode" src="/images/graycode.png" /&gt;&lt;br /&gt;
&lt;img alt="graycode1" src="/images/graycode1.png" /&gt;  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/*************************************************************************&lt;/span&gt;
&lt;span class="cm"&gt;    &amp;gt; File Name: graycode.cpp&lt;/span&gt;
&lt;span class="cm"&gt;    &amp;gt; Author: zzfan&lt;/span&gt;
&lt;span class="cm"&gt;    &amp;gt; Mail: zzfan@mail.ustc.edu.cn &lt;/span&gt;
&lt;span class="cm"&gt;    &amp;gt; Created Time: 2016年03月20日 星期日 16时59分47秒&lt;/span&gt;
&lt;span class="cm"&gt; ************************************************************************/&lt;/span&gt;

&lt;span class="c1"&gt;//对称性&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;math.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;getGray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
&lt;span class="c1"&gt;//    int flag = 0;&lt;/span&gt;
&lt;span class="c1"&gt;//    int step = 0;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;gray&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;gray&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;0&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;gray&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;gray&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;last&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getGray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;lastsize&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;last&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;size&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;currentsize&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;lastsize&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;currentsize&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;lastsize&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
            &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;0&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;last&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
            &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;currentsize&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;1&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;last&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cin&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;gray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;getGray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nf"&gt;pow&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
            &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;gray&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary><category term="笔试"></category></entry><entry><title>数组的翻转和单链表的翻转</title><link href="http://blog.zzfanhero.info/articles/shu-zu-de-fan-zhuan-he-dan-lian-biao-de-fan-zhuan.html" rel="alternate"></link><updated>2016-03-19T00:00:00+08:00</updated><author><name>zzfan</name></author><id>tag:blog.zzfanhero.info,2016-03-19:articles/shu-zu-de-fan-zhuan-he-dan-lian-biao-de-fan-zhuan.html</id><summary type="html">&lt;p&gt;摘要：从最简单的开始，刚被网易的笔试给虐了&lt;/p&gt;
&lt;h3&gt;* 数组的翻转&lt;/h3&gt;
&lt;p&gt;&lt;i class="icon-file"&gt;&lt;/i&gt;这里用string的翻转为例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/*************************************************************************&lt;/span&gt;
&lt;span class="cm"&gt;    &amp;gt; File Name: test.cpp&lt;/span&gt;
&lt;span class="cm"&gt;    &amp;gt; Author: zzfan&lt;/span&gt;
&lt;span class="cm"&gt;    &amp;gt; Mail: zzfan@mail.ustc.edu.cn &lt;/span&gt;
&lt;span class="cm"&gt;    &amp;gt; Created Time: 2016年03月19日 星期六 20时20分04秒&lt;/span&gt;
&lt;span class="cm"&gt; ************************************************************************/&lt;/span&gt;

&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;algorithm&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stack&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;//c style&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;c_rever&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;temp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="n"&gt;my&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;who are you!&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;my&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;size&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;c_rever&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;my&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;my&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;reverse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;my&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;my&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;end&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
    &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;my&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;//stack&lt;/span&gt;
    &lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;my&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;empty&lt;/span&gt;&lt;span class="p"&gt;()){&lt;/span&gt;
        &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;top&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;* 单链表的翻转&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Llist list\_reverse(Llist list)
{
    Lnode *tmp = null;
    Lnode *p = null;

    if(list == NULL) return NULL;
    tmp = list-&amp;gt;next;
    while(tmp-&amp;gt;next != NULL){
        p = tmp-&amp;gt;next;
        tmp-&amp;gt;next = p-&amp;gt;next;
        p-&amp;gt;next = list-&amp;gt;next;
        list-&amp;gt;next = p;
    }
    return list;
}
&lt;/pre&gt;&lt;/div&gt;</summary><category term="面试"></category></entry><entry><title>无temp的Swap以及位运算加减法</title><link href="http://blog.zzfanhero.info/articles/wu-tempde-swapyi-ji-wei-yun-suan-jia-jian-fa.html" rel="alternate"></link><updated>2016-03-19T00:00:00+08:00</updated><author><name>zzfan</name></author><id>tag:blog.zzfanhero.info,2016-03-19:articles/wu-tempde-swapyi-ji-wei-yun-suan-jia-jian-fa.html</id><summary type="html">&lt;p&gt;&lt;font color=Green&gt;摘要：以前听别人提起过，面试连这样的题都有，也就花几分钟整理整理 &lt;/font&gt;&lt;/p&gt;
&lt;h3&gt;* 不用中间变量的Swap&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;加减法&lt;br /&gt;
//该方法可以狡猾整形和浮点型数值的变量，但是再处理浮点型的时候可能出现精度受损&lt;br /&gt;
a = a + b;&lt;br /&gt;
b = a - b;&lt;br /&gt;
a = a - b;  &lt;/li&gt;
&lt;li&gt;已获法：对浮点型无法交换&lt;br /&gt;
a = a^b;&lt;br /&gt;
b = a^b;&lt;br /&gt;
a = a^b;  &lt;/li&gt;
&lt;li&gt;乘除法&lt;br /&gt;
a = a*b&lt;br /&gt;
b = a/b&lt;br /&gt;
a = a/b  &lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;* 位运算实现加减乘除&lt;/h3&gt;</summary><category term="面试"></category></entry></feed>